<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ボスタイピング（JRPG UI）</title>
  <style>
    :root{
      --bg:#0a0c13;
      --ink:#f3f6ff;
      --muted:#b8c3e6;
      --gold:#d9c27a;
      --wordH: 30;
    }

    *{ box-sizing:border-box; }

    .muted{ color: var(--muted); }
    body{
      margin:0;
      background: radial-gradient(900px 520px at 50% 0%, rgba(100,120,255,.16), transparent 60%),
                  radial-gradient(1000px 600px at 10% 100%, rgba(255,140,100,.10), transparent 55%),
                  var(--bg);
      color:var(--ink);
      font-family: ui-monospace, "MS Gothic", "Osaka", "Noto Sans JP", monospace;

      transition: filter .12s ease;

      display:flex;
      justify-content:center;
      align-items:center;

      min-height:100dvh;
      padding:
        calc(16px + env(safe-area-inset-top))
        16px
        calc(16px + env(safe-area-inset-bottom))
        16px;

      overflow-x:hidden;
      -webkit-text-size-adjust: 100%;
    }

    .pixel{
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    .frame{
      width:min(1024px, 100%);
      border:6px solid var(--gold);
      box-shadow: 0 0 0 2px rgba(0,0,0,.45), inset 0 0 0 2px rgba(0,0,0,.45);
      background: rgba(0,0,0,.20);
      touch-action: manipulation;
    }

    .battlefield{
      position:relative;
      isolation:isolate;
      height: min(520px, 56vh);
      border-bottom:6px solid var(--gold);
      overflow:hidden;
      background: linear-gradient(180deg, rgba(40,45,70,.55), rgba(10,12,19,.75));
      transition: filter .12s ease;
    }

    .bgImg{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover;
      opacity: 0.85;
      display:none;
    }
    .bgFallback{
      position:absolute; inset:0;
      background:
        radial-gradient(240px 180px at 20% 20%, rgba(255,210,120,.18), transparent 60%),
        radial-gradient(220px 180px at 70% 30%, rgba(120,160,255,.18), transparent 60%),
        linear-gradient(180deg, rgba(30,35,60,.55), rgba(10,12,19,.75));
    }

    /* Word lane */
    .wordLane{
      position:absolute;
      z-index:1;
      left: 26px;
      top: 22px;
      bottom: 84px; /* leave space for input bar under the lane */
      width: min(360px, 46%);
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      background: rgba(10,10,18,.35);
      overflow:hidden;
    }

    /* Dream-like Phase 5: give the word lane more room so long English answers don't clip */
    body.dreamlike .wordLane{
      width: min(560px, 70%);
    }

    /* EX2 Phase 5 hard-switch: negative colors for the whole page */
    body.negativeModeAll{
      filter: invert(1) hue-rotate(180deg);
    }

.laneLabel{
      position:absolute;
      left: 36px;
      top: 30px;
      z-index:3;
      background: rgba(0,0,0,.55);
      border:2px solid rgba(255,255,255,.12);
      padding:6px 10px;
      font-size:12px;
      color: var(--muted);
    }

    .overflowBadge{
      position:absolute;
      right: 18px;
      top: 18px;
      z-index:5;
      background: rgba(255,220,120,.95);
      color:#140e00;
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.12);
      padding:6px 10px;
      font-weight:900;
      display:none;
    }
    .overflowBadge.show{ display:block; }

    /* Input bar directly under falling words */
    .inputBar{
      position:absolute;
      left: 26px;
      bottom: 22px;
      width: min(360px, 46%);
      height: 52px;
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08), 0 10px 18px rgba(0,0,0,.35);
      background: rgba(0,0,0,.32);
      z-index:6;
      display:flex;
      align-items:center;
      padding: 8px 10px;
      gap:10px;
    }
    .promptChar{
      color: var(--gold);
      font-weight:900;
      font-size:16px;
      flex: 0 0 auto;
    }
    .inputBar form{
      display:flex;
      align-items:center;
      gap:10px;
      width:100%;
      height:100%;
      margin:0;
    }
    .inputBar input[type="text"]{
      width:100%;
      background: transparent;
      border:none;
      outline:none;
      color: var(--ink);
      font-size:16px;
      font-family: inherit;
      height: 36px;
      padding: 4px 6px;
    }
    .inputBar input[type="text"]::placeholder{ color: rgba(184,195,230,.65); }

    .word{
      position:absolute;
      z-index:2;
      left:50%;
      top:0;
      transform: translate3d(-50%, var(--y, 0px), 0);
      will-change: transform;
      width: calc(100% - 22px);
      height: calc(var(--wordH) * 1px);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:0 10px;

      background: rgba(26,22,48,.85);
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08), 0 8px 12px rgba(0,0,0,.35);
      transition: opacity 180ms ease, filter 180ms ease;
    }
    .word.s4Switching{ opacity:.35; filter: blur(1px); }
    .word.s4Switching .tag{ opacity:.9; }
    .word .prompt{
      font-weight:900;
      letter-spacing:.2px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      flex: 1 1 auto;
      min-width: 0;
    }
    .word .tag{
      color: var(--muted);
      font-size:12px;
      flex:0 0 auto;
      white-space:nowrap;
    }

    .word .right{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:8px;
      min-width:0;
      flex: 0 1 auto;
      max-width: 62%;
    }
    .word .answer{
      display:inline-block;
      min-width:0;
      max-width:100%;
      white-space:nowrap;
      text-align:right;
      overflow:hidden;
      text-overflow:ellipsis;
      will-change: transform;
    }

    .word.hint .tag{
      color: var(--gold);
      font-weight:900;
    }
    .word.landed{
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.06);
      background: rgba(18,16,34,.85);
    }
    .word.obscured .answer{
      color: rgba(243,246,255,.55);
      letter-spacing: 0px;
      padding-left: 2px;
}


    
    
.word.s1Target{
  border-color: rgba(255,220,100,.95);
  box-shadow: 0 0 0 1px rgba(255,220,100,.45), 0 0 18px rgba(255,220,100,.18);
}

.word.ex2Target{
      border-color: rgba(255, 204, 0, .85);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.10), 0 0 0 2px rgba(255, 204, 0, .25), 0 8px 12px rgba(0,0,0,.35);
    }


.word.s2Target{
  /* Stage 2 highlighted (falling): ORANGE */
  border-color: rgba(255, 170, 60, .95);
  box-shadow: 0 0 0 1px rgba(255, 170, 60, .35), 0 0 18px rgba(255, 170, 60, .18);
}

.word.s2Target.flash{
  /* Stage 2 highlighted (flashing): RED */
  border-color: rgba(255, 70, 70, .95);
  box-shadow: 0 0 0 1px rgba(255, 70, 70, .45), 0 0 22px rgba(255, 70, 70, .22);
}

.word.s5Target{
  border-color: rgba(160, 235, 255, .92);
  box-shadow: 0 0 0 1px rgba(160, 235, 255, .35), 0 0 20px rgba(160, 235, 255, .18);
}


.word.ex1Target{
  border-color: rgba(190, 245, 255, .95);
  box-shadow: 0 0 0 1px rgba(190, 245, 255, .35), 0 0 22px rgba(190, 245, 255, .18);
}

.word.ghost{
  opacity: .78;
}

.word.permafrost{
  border-color: rgba(190, 245, 255, .95);
  border-style: dashed;
  background: rgba(18, 34, 58, .92);
  box-shadow: inset 0 0 0 2px rgba(255,255,255,.06), 0 0 0 2px rgba(190, 245, 255, .18), 0 10px 16px rgba(0,0,0,.35);
}
.word.permafrost .tag{
  color: rgba(190, 245, 255, .95);
  font-weight: 900;
}

/* NEW: Normal Stage 3 forbidden highlight */
.s3Forbidden{
  border-color: rgba(255, 120, 200, .92);
  box-shadow: 0 0 0 1px rgba(255, 120, 200, .35), 0 0 20px rgba(255, 120, 200, .18);
}

.word.flash{
  animation: stage2Flash 0.25s steps(2,end) infinite;
}

@keyframes stage2Flash{
  0%{ filter: brightness(1); }
  50%{ filter: brightness(1.7); }
  100%{ filter: brightness(1); }
}


/* Boss area */
    .bossWrap{
      position:absolute;
      right: 70px;
      top: 44px;
      bottom: 44px;
      width: min(360px, 42%);
      display:grid;
      place-items:center;
      pointer-events:none;
    }
    .bossInner{
      position:relative;
      width:100%;
      height:100%;
      display:grid;
      place-items:center;
    }
    .bossImg{
      width:100%;
      height:100%;
      object-fit:contain;
      display:none;
      filter: drop-shadow(0 10px 0 rgba(0,0,0,.35));
    }
    .bossFallback{
      width:100%;
      height:100%;
      display:grid;
      place-items:center;
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      background: rgba(0,0,0,.22);
      color: rgba(243,246,255,.85);
      font-weight:900;
      text-align:center;
      padding:12px;
    }

    .stage5Timer{
      position:absolute;
      right: 10px;
      top: 56px;
      padding:10px 14px;
      font-size:16px;
      font-weight:900;
      color: var(--gold);
      background: rgba(0,0,0,.66);
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08), 0 10px 18px rgba(0,0,0,.35);
      display:none;
      z-index:8;
      letter-spacing:.2px;
      text-align:center;
      min-width: 160px;
    }
    .stage5Timer.show{ display:block; }

    

    /* Normal Stage 3: forbidden-cycle timer */
    .stage3Timer{
      position:absolute;
      right: 10px;
      top: 56px;
      padding:10px 14px;
      font-size:16px;
      font-weight:900;
      color: rgba(255, 120, 200, .95);
      background: rgba(0,0,0,.66);
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 2px rgba(255,255,255,.08), 0 10px 18px rgba(0,0,0,.35);
      display:none;
      z-index:8;
      letter-spacing:.2px;
      text-align:center;
      min-width: 160px;
      pointer-events:none;
    }
    .stage3Timer.show{ display:block; }

    /* Normal Stage 4: switch-all-words timer */
    .stage4Timer{
      position:absolute;
      right: 10px;
      top: 56px;
      padding:10px 14px;
      font-size:16px;
      font-weight:900;
      color: var(--gold);
      background: rgba(0,0,0,.66);
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08), 0 10px 18px rgba(0,0,0,.35);
      display:none;
      z-index:8;
      letter-spacing:.2px;
      text-align:center;
      min-width: 160px;
    }
    .stage4Timer.show{ display:block; }


    /* Extra Stage 2: shuffle timer */
    .ex2Timer{
      position:absolute;
      right: 10px;
      top: 56px;
      padding:10px 14px;
      font-size:16px;
      font-weight:900;
      color: var(--gold);
      background: rgba(0,0,0,.66);
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08), 0 10px 18px rgba(0,0,0,.35);
      display:none;
      z-index:8;
      letter-spacing:.2px;
      text-align:center;
      min-width: 160px;
    }
    .ex2Timer.show{ display:block; }

    /* Extra Stage 2: survive timer (until BGM ends) */
    .ex2EndTimer{
      position:absolute;
      right: 10px;
      top: 104px;
      padding:10px 14px;
      font-size:16px;
      font-weight:900;
      color: var(--gold);
      background: rgba(0,0,0,.66);
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08), 0 10px 18px rgba(0,0,0,.35);
      display:none;
      z-index:8;
      letter-spacing:.2px;
      text-align:center;
      min-width: 160px;
    }
    .ex2EndTimer.show{ display:block; }


    /* Extra Stage 4: survive timer (until BGM ends) */
    .ex4Timer{
      position:absolute;
      right: 10px;
      top: 56px;
      padding:10px 14px;
      font-size:16px;
      font-weight:900;
      color: var(--gold);
      background: rgba(0,0,0,.66);
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08), 0 10px 18px rgba(0,0,0,.35);
      display:none;
      z-index:8;
      letter-spacing:.2px;
      text-align:center;
      min-width: 160px;
    }
    .ex4Timer.show{ display:block; }

    /* Boss HP "X" overlay (invulnerable boss) */
    #bossMeter.invuln{ position: relative; }
    #bossMeter.invuln::after{
      content:"✕";
      position:absolute;
      left:50%;
      top:50%;
      transform: translate(-50%, -58%);
      font-size:28px;
      font-weight:900;
      color: rgba(255,90,90,.95);
      text-shadow: 0 3px 10px rgba(0,0,0,.75);
      pointer-events:none;
      line-height:1;
    }


    .bossBubble{
      position:absolute;
      left:50%;
      top: 12px;
      transform: translateX(-50%);
      max-width: 92%;
      padding:8px 10px;
      font-size:13px;
      line-height:1.45;
      color: var(--ink);
      background: rgba(0,0,0,.66);
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08), 0 10px 18px rgba(0,0,0,.35);
      opacity:0;
      display:none;
      z-index:9;
      text-align:center;
    }
    .bossBubble.show{
      display:block;
      animation: bubbleIn .12s ease-out forwards;
    }
    @keyframes bubbleIn{
      from { opacity:0; transform: translateX(-50%) translateY(-6px); }
      to   { opacity:1; transform: translateX(-50%) translateY(0); }
    }
    .bossBubble:after{
      content:"";
      position:absolute;
      left:50%;
      bottom:-10px;
      transform: translateX(-50%);
      width:0; height:0;
      border-left:10px solid transparent;
      border-right:10px solid transparent;
      border-top:10px solid rgba(0,0,0,.66);
      filter: drop-shadow(0 2px 0 rgba(0,0,0,.35));
    }


    .bossFlash{ animation: bossFlash .14s linear; }
    @keyframes bossFlash{
      0%{ filter: brightness(1) contrast(1) drop-shadow(0 10px 0 rgba(0,0,0,.35)); }
      50%{ filter: brightness(2.4) contrast(1.2) drop-shadow(0 10px 0 rgba(0,0,0,.35)); }
      100%{ filter: brightness(1) contrast(1) drop-shadow(0 10px 0 rgba(0,0,0,.35)); }
    }

    .damageFlash{
      position:absolute;
      inset:0;
      pointer-events:none;
      background: rgba(255, 0, 0, .22);
      opacity:0;
      z-index:6;
    }
    .damageFlash.show{ animation: dmgFlash .22s ease-out; }
    @keyframes dmgFlash{
      0%{ opacity:0; }
      25%{ opacity:1; }
      100%{ opacity:0; }
    }

    /* Bottom UI */
    .uiRow{
      display:grid;
      grid-template-columns: 1fr 1.2fr 1.1fr;
      gap:10px;
      padding:10px;
      background: rgba(0,0,0,.22);
    }

    .panel{
      background: linear-gradient(180deg, rgba(26,22,48,.92), rgba(18,16,34,.92));
      border:6px solid var(--gold);
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.55);
      padding:10px;
      min-height: 160px;
    }

    .panelHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
      padding-bottom:6px;
      border-bottom:2px solid rgba(255,255,255,.12);
      color: var(--muted);
      font-size:12px;
    }
    .panelHeader b{ color: var(--ink); }

    .menuList{
      list-style:none;
      padding:0;
      margin:0;
      display:grid;
      gap:8px;
      font-size:16px;
    }
    .menuItem{
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px 6px;
      border:2px solid transparent;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
    }
    #runCmd{ margin-top: 18px; }
    .menuItem:hover{
      border-color: rgba(255,255,255,.16);
      background: rgba(255,255,255,.04);
    }
    .menuItem.disabled{
      opacity:.45;
      cursor:not-allowed;
    }
    .menuItem.disabled:hover{
      border-color: transparent;
      background: transparent;
      outline: none;
    }
    .menuItem.disabled .arrow{ color: rgba(184,195,230,.65); }
    
    .menuItem.crossedOut{
      position: relative;
      overflow: hidden; /* keep the glow contained to this button */
    }
    /* Keep the strike fully contained inside ONLY this menu item */
    .menuItem.crossedOut > *{
      position: relative;
      z-index: 1;
    }
    .menuItem.crossedOut::after{
      content:"";
      position:absolute;
      inset:0;
      z-index:2;
      pointer-events:none;
      opacity:1;
      /* White core line with a bright red glow (EX2 only) */
      background-image:
        /* soft outer glow */
        linear-gradient(to bottom,
          transparent 41%,
          rgba(255, 20, 20, 0.00) 43%,
          rgba(255, 20, 20, 0.30) 46%,
          rgba(255, 20, 20, 0.30) 54%,
          rgba(255, 20, 20, 0.00) 57%,
          transparent 59%),
        /* brighter inner glow */
        linear-gradient(to bottom,
          transparent 45%,
          rgba(255, 30, 30, 0.00) 46.5%,
          rgba(255, 30, 30, 0.80) 48.5%,
          rgba(255, 30, 30, 0.80) 51.5%,
          rgba(255, 30, 30, 0.00) 53.5%,
          transparent 55%),
        /* white core */
        linear-gradient(to bottom,
          transparent 48.9%,
          rgb(255,255,255) 49.6%,
          rgb(255,255,255) 50.4%,
          transparent 51.1%);
      background-repeat:no-repeat;
      background-size:100% 100%;
    }

.arrow{
      width:18px;
      color: var(--gold);
      font-weight:900;
    }

    .msg{
      font-size:14px;
      line-height:1.55;
      color: var(--ink);
      min-height: 120px;
      padding:6px 6px 10px;
      border:2px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
      overflow:auto;
      max-height: 140px;
    }
    .msg .muted{ color: var(--muted); }

    .small{
      margin-top:6px;
      font-size:12px;
      color: var(--muted);
    }

    .statusList{ display:grid; gap:10px; font-size:13px; }
    .statRow{
      display:grid;
      grid-template-columns: auto 1fr;
      gap:10px;
      align-items:center;
    }
    .statRow .name{
      width: 90px;
      color: var(--ink);
      font-weight:900;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .bars{ display:grid; gap:8px; }
    .barLine{
      display:grid;
      grid-template-columns: 28px 1fr auto;
      gap:8px;
      align-items:center;
      color: var(--muted);
      font-size:12px;
    }
    .meter{
      height: 12px;
      border:3px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      background: rgba(255,255,255,.08);
      overflow:hidden;
    }
    .fillHP{
      height:100%;
      width:50%;
      background: linear-gradient(90deg, rgba(214,66,66,1), rgba(255,140,140,1));
    }
    .fillBoss{
      height:100%;
      width:50%;
      background: linear-gradient(90deg, rgba(255,110,90,1), rgba(255,190,120,1));
    }
    .fillAP{
      height:100%;
      width:40%;
      background: linear-gradient(90deg, rgba(106,70,255,1), rgba(170,140,255,1));
    }

    .hpPips{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:8px;
      padding-top:8px;
      border-top:2px solid rgba(255,255,255,.10);
    }
    .pip{
      width:12px;
      height:12px;
      border:2px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      background: rgba(255,255,255,.08);
    }
    .pip.on{
      background: linear-gradient(90deg, rgba(49,210,124,1), rgba(120,255,190,1));
    }

    .bgmRow{
      margin-top:8px;
      padding-top:8px;
      border-top:2px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      color: var(--muted);
      font-size:12px;
    }
    .bgmRow b{ color: var(--ink); }
    .bgmRow input[type="range"]{
      width: 140px;
      accent-color: var(--gold);
    }

.bgmBtn{
      border:2px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      background: rgba(0,0,0,.22);
      color: var(--ink);
      padding:8px 10px;
      cursor:pointer;
      font-family: inherit;
      font-size:12px;
      font-weight:900;
      min-height: 40px;
      touch-action: manipulation;
    }

    .overlay{
      position:fixed;
      inset:0;
      display:none;
      place-items:center;
      z-index: 5000;
      background: rgba(0,0,0,.72);
      cursor:pointer;
      overflow:hidden;
      padding:24px 12px;
      box-sizing:border-box;
    }
    .overlay.show{ display:grid; }

    /* When an in-game overlay is open (Continue/Debug/Dialogue/Mode Select),
       force the overlay to be the only clickable layer. */
    .battlefield.overlayOpen .wordLane,
    .battlefield.overlayOpen .wordLane .word,
    .battlefield.overlayOpen .inputBar,
    .battlefield.overlayOpen .laneLabel,
    .battlefield.overlayOpen .overflowBadge{
      pointer-events:none;
    }

    .overlayBox{
width:min(600px, calc(100% - 30px));
      background: linear-gradient(180deg, rgba(26,22,48,1), rgba(18,16,34,1));
      border:6px solid var(--gold);
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.55);
      padding:14px;
      text-align:left;
      overflow-wrap:anywhere;
      word-break: break-word;
      overflow:auto;
      max-height: calc(100vh - 48px);
      -webkit-overflow-scrolling: touch;
      box-sizing: border-box;
      position:relative;
    }
    .overlayBox h2{ margin:0 0 8px; font-size:18px; }
    .overlayBox p{ margin:0; color: var(--ink); font-size:14px; line-height:1.7; }
    .overlayHint{ margin-top:10px; color: var(--muted); font-size:12px; }
    
    /* DEBUG: compact stage picker */
    .overlayBox.debugSmall{
      width:min(360px, calc(100% - 30px));
      padding:10px;
    }
    .overlayBox.debugSmall p,
    .overlayBox.debugSmall .overlayHint{
      display:none;
    }
    .overlayBox.debugSmall h2{
      margin:0 0 6px;
      font-size:16px;
      letter-spacing:.06em;
    }
    .debugGrid{
      margin-top:6px;
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:8px;
    }
    .debugStageBtn{
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;
      background: rgba(0,0,0,.22);
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      padding:10px 6px;
      font-weight:900;
      color: var(--gold);
      text-align:center;
      border-radius:10px;
    }
    .debugStageBtn:hover{
      outline:2px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.04);
    }
.countdown{ margin-top:10px; font-size:42px; font-weight:900; color: var(--gold); text-align:center; }

    .overlayChoices{
      display:none;
      margin-top:10px;
      display:grid;
      gap:10px;
    }
    .overlayChoices.show{ display:grid; }

    .choiceBtn{
      cursor:pointer;
      user-select:none;
      background: rgba(0,0,0,.22);
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      padding:12px;
      touch-action: manipulation;
    }
    .choiceBtn:hover{
      outline:2px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.04);
    }
    .choiceBtn .title{
      font-weight:900;
      color: var(--gold);
      margin-bottom:4px;
    }
    .choiceBtn .desc{
      font-size:13px;
      color: var(--ink);
      line-height:1.55;
    }
    .choiceBtn .note{
      margin-top:6px;
      font-size:12px;
      color: var(--muted);
    }

    .stageClearSlide{
      display:inline-block;
      font-size:26px;
      letter-spacing:.5px;
      animation: stageClearSlide .55s cubic-bezier(.18,.9,.22,1) both;
    }
    @keyframes stageClearSlide{
      0%   { transform: translateX(-56px); opacity: 0; }
      65%  { transform: translateX(8px); opacity: 1; }
      100% { transform: translateX(0); opacity: 1; }
    }

    @media (max-width: 980px){
      .uiRow{ grid-template-columns: 1fr; }
      .panel{ min-height: unset; }
      .bossWrap{ right: 18px; top: 34px; bottom: 34px; width: 46%; }
      .wordLane{ width: 52%; }
      .inputBar{ width: 52%; }
      .stage5Timer{ top: 52px; }
    }
  .bossHpLine{ position: relative; overflow: hidden; }
    /* ---- Intro start screen (pre-menu) ---- */
    .introOverlay{
      position:fixed;
      inset:0;
      background:#000;
      z-index:1000;
      display:none;
      user-select:none;
      -webkit-user-select:none;
      touch-action:manipulation;
    }
    .introOverlay.show{ display:block; }
    .introBlackout{
      position:absolute;
      inset:0;
      background:#000;
    }

    .introBg{
      position:absolute;
      inset:0;
      background:#05040b;
      background-image: var(--introBg, none);
      background-size:cover;
      background-position:center;
      background-repeat:no-repeat;
      image-rendering: pixelated;
      opacity: 1;
      transition: opacity 160ms linear, filter 120ms linear, transform 120ms linear;
      will-change: opacity, filter, transform;
    }

    /* Intro unlocked background glitch reveal */
    .introBg.introHidden{ opacity: 0; }
    .introBg.introGlitching{ }
    .introBg::before,
    .introBg::after{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;
      opacity:0;
    }
    .introBg::before{
      /* scanlines */
      background: repeating-linear-gradient(
        0deg,
        rgba(255,255,255,.06) 0px,
        rgba(255,255,255,.06) 1px,
        transparent 1px,
        transparent 3px
      );
      mix-blend-mode: overlay;
    }
    .introBg::after{
      /* RGB split tint */
      background: linear-gradient(90deg, rgba(255,40,120,.22), transparent 40%, rgba(0,170,255,.22));
      mix-blend-mode: screen;
      transform: translateX(var(--gShiftX, 0px));
    }
    .introBg.introGlitchPulse{
      filter: contrast(1.25) saturate(1.35) brightness(1.10);
      transform: translate(var(--gX, 0px), var(--gY, 0px)) skewX(var(--gSkew, 0deg));
    }
    .introBg.introGlitchPulse::before{ opacity: .55; }
    .introBg.introGlitchPulse::after{ opacity: .70; }
    .introShade{
      position:absolute;
      inset:0;
      background:
        radial-gradient(1200px 700px at 50% 30%, rgba(0,0,0,.12), rgba(0,0,0,.75)),
        rgba(0,0,0,.25);
      opacity:1;
      transition: opacity 520ms ease;
    }
    /* Once loading is done, let the background be fully clear */
    .introOverlay[data-state="ready"] .introShade{ opacity:0; }
    .introContent{
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-end;
      gap:12px;
      padding:26px 18px calc(28px + env(safe-area-inset-bottom, 0px));
    }
    .introBadge{
      font-weight:900;
      letter-spacing:.06em;
      font-size:14px;
      padding:8px 12px;
      border:3px solid rgba(255,255,255,.2);
      background: rgba(0,0,0,.35);
      text-shadow: 0 2px 0 rgba(0,0,0,.65);
      border-radius:10px;
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
    }
    .introStartBtn{
      font-family: inherit;
      font-weight: 1000;
      letter-spacing: .14em;
      padding: 12px 20px;
      border: 5px solid var(--gold);
      background: rgba(16,14,30,.92);
      color: var(--ink);
      border-radius: 14px;
      box-shadow: 0 10px 0 rgba(0,0,0,.35);
      min-width: 210px;
      height: 54px;
      cursor:pointer;
      opacity:1;
      transform: translateY(0);
      pointer-events:auto;
      transition: filter .18s ease, opacity .18s ease;
    }
    .introStartBtn[disabled]{
      opacity: .6;
      cursor: default;
      filter: grayscale(.25) brightness(.9);
      box-shadow: 0 8px 0 rgba(0,0,0,.30);
    }
    .introNote{
      font-size:12px;
      color: var(--muted);
      text-shadow: 0 2px 0 rgba(0,0,0,.6);
      opacity: .95;
    }

    /* ---- Center profile display on startup window ---- */
    .introProfileCard{
      position:absolute;
      top:50%;
      left:50%;
      transform: translate(-50%, -50%);
      display:flex;
      align-items:center;
      gap:16px;
      padding:16px 18px;
      border:3px solid rgba(255,255,255,.22);
      background: rgba(0,0,0,.42);
      border-radius:16px;
      box-shadow: 0 12px 0 rgba(0,0,0,.35);
      max-width: min(560px, calc(100% - 46px));
      pointer-events:none; /* purely informational */
    }
    .introProfileIcon{
      width:84px;
      height:84px;
      border-radius:18px;
      border:3px solid rgba(255,255,255,.25);
      background: rgba(255,255,255,.06);
      object-fit: cover;
      flex:0 0 auto;
    }
    .introProfileText{
      display:flex;
      flex-direction:column;
      gap:8px;
      min-width: 0;
    }
    .introProfileName{
      font-weight:1000;
      letter-spacing:.02em;
      font-size:24px;
      line-height:1.05;
      color: var(--ink);
      text-shadow: 0 2px 0 rgba(0,0,0,.65);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 380px;
    }
    .introProfileLevel{
      font-weight:900;
      font-size:15px;
      color: var(--muted);
      text-shadow: 0 2px 0 rgba(0,0,0,.55);
    }

    .introProfileExp{
      font-weight:800;
      font-size:13px;
      color: var(--muted);
      text-shadow: 0 2px 0 rgba(0,0,0,.55);
      margin-top:2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 380px;
    }
    @media (max-width: 420px){
      .introProfileIcon{ width:72px; height:72px; border-radius:16px; }
      .introProfileName{ font-size:20px; max-width: 260px; }
      .introProfileCard{ gap:12px; padding:14px 14px; }
    }



    /* ---- Dream-like (EX2 Phase 5 fake Stage 1) ---- */
    body.dreamlike{
      /* very subtle overall softening */
      background: #05060a;
    }
    body.dreamlike #app{
      filter: saturate(0.95) contrast(0.95) brightness(1.05);
    }
    body.dreamlike::before{
      content:"";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        radial-gradient(circle at 28% 22%, rgba(190,210,255,0.12), transparent 55%),
        radial-gradient(circle at 72% 78%, rgba(255,210,230,0.10), transparent 60%);
      mix-blend-mode: screen;
      opacity: 0.9;
      animation: dreamPulse 8s ease-in-out infinite;
    }
    body.dreamlike::after{
      content:"";
      position: fixed;
      inset: -20%;
      pointer-events: none;
      background-image:
        repeating-linear-gradient(0deg,
          rgba(255,255,255,0.02),
          rgba(255,255,255,0.02) 1px,
          transparent 1px,
          transparent 5px);
      opacity: 0.14;
      animation: dreamDrift 12s linear infinite;
    }
    @keyframes dreamPulse{
      0%{ opacity: 0.75; filter: blur(0px); }
      50%{ opacity: 1.0; filter: blur(0.2px); }
      100%{ opacity: 0.75; filter: blur(0px); }
    }
    @keyframes dreamDrift{
      0%{ transform: translate3d(-1%, -0.5%, 0) rotate(0.2deg); }
      50%{ transform: translate3d(1%, 0.8%, 0) rotate(-0.2deg); }
      100%{ transform: translate3d(-1%, -0.5%, 0) rotate(0.2deg); }
    }
    body.dreamlike .word{
      filter: drop-shadow(0 0 6px rgba(190,210,255,0.22));
      /* NOTE: do not animate transform here; .word uses transform for positioning */
    }
    @keyframes dreamFloat{
      0%{ transform: translateY(0px); }
      50%{ transform: translateY(-2px); }
      100%{ transform: translateY(0px); }
    }
    body.dreamlike .wakeUpWord{
      letter-spacing: 0.06em;
      filter: drop-shadow(0 0 10px rgba(255,255,255,0.28));
    }
    body.dreamlike .wakeUpWord .answer{
      font-weight: 800;
      text-transform: uppercase;
    }


    /* ---- Profile / Achievements UI ---- */
    /* Hide Profile/Achievements entries from the in-game command list (moved to Mode Select) */
    #profileCmd, #achievementsCmd{ display:none; }

    .playerHeaderWrap{
      display:flex;
      align-items:center;
      gap: 12px;
      min-width:0;
    }

    .playerMeta{
      display:flex;
      flex-direction:column;
      gap:4px;
      min-width:0;
    }
    .playerNameRow{
      display:flex;
      align-items:baseline;
      gap:6px;
      min-width:0;
    }
    .playerMeta .playerLevel{ margin-left:0; }
    .playerMeta .playerExp{
      margin-left:0;
      align-self:flex-start;
    }
    .playerIcon{
      width: 56px;
      height: 56px;
      border:3px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      background: rgba(0,0,0,.22);
      border-radius: 14px;
      object-fit:cover;
      flex: 0 0 auto;
    }
    .playerHeaderWrap #playerLabel{
      font-size: 19px;
      line-height: 1.05;
      letter-spacing:0.02em;
      max-width:  240px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      display:inline-block;
      transform: translateY(1px);
    }
    .playerLevel{
      margin-left:6px;
      font-size: 15px;
      white-space:nowrap;
      flex: 0 0 auto;
      transform: translateY(1px);
    }

    .playerExp{
      margin-left:8px;
      font-size: 13px;
      white-space:nowrap;
      flex: 0 0 auto;
      transform: translateY(1px);
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.10);
    }

    /* Use same overlay styling, but for profile/ach overlays too */
    .overlay .overlayBox .profileForm{
      margin-top:10px;
      display:grid;
      gap:10px;
    }
    .profileLabel{
      font-size:12px;
      color: var(--muted);
      font-weight:900;
      letter-spacing:.04em;
      margin-bottom:4px;
    }
    .profileInput{
      width:100%;
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      background: rgba(0,0,0,.22);
      color: var(--ink);
      padding:10px 10px;
      font-family: inherit;
      font-size:14px;
      border-radius:12px;
      outline:none;
    }
    .profileInput::placeholder{ color: rgba(184,195,230,.65); }

    .iconGrid{
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap: 12px;
    }
    @media (max-width: 520px){
      .iconGrid{ grid-template-columns: repeat(3, minmax(0,1fr)); }
    }
.iconBtn{
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      background: rgba(0,0,0,.22);
      border-radius:14px;
      cursor:pointer;
      user-select:none;
      touch-action: manipulation;

      /* Make each icon tile a square (not a pill/rectangle) */
      aspect-ratio: 1 / 1;
      position:relative;
      overflow:hidden;

      /* Reserve space for the price/locked tags at the bottom */
      padding:10px 10px 48px;

      display:grid;
      place-items:center;
    }
.iconBtn:hover{ outline:2px solid rgba(255,255,255,.18); background: rgba(255,255,255,.04); }
    .iconBtn[aria-disabled="true"]{
      opacity:.40;
      cursor:not-allowed;
    }
    .iconBtn[aria-disabled="true"]:hover{ outline:none; background: rgba(0,0,0,.22); }
    .iconBtn.selected{
      border-color: rgba(255,220,120,.95);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.10), 0 0 0 2px rgba(255,220,120,.22);
    }
    .iconImg{
      width: 140px;
      height: 140px;
      max-width: calc(100% - 4px);
      max-height: calc(100% - 4px);
      border-radius: 12px;
      object-fit:cover;
      background: rgba(0,0,0,.18);
    }
.iconPriceTag{
      position:absolute;
      left:8px;
      right:8px;
      bottom:10px;
      z-index:2;

      font-size:11px;
      line-height:1.15;
      padding:5px 10px;
      border-radius:999px;

      background: rgba(0,0,0,.82);
      color: rgba(255,255,255,.98);
      border:1px solid rgba(255,255,255,.18);

      text-align:center;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      pointer-events:none;
    }
.iconLockedNote{
      position:absolute;
      left:8px;
      right:8px;
      bottom:38px;
      z-index:2;

      font-size:11px;
      line-height:1.15;
      padding:4px 10px;
      border-radius:999px;

      background: rgba(220,80,80,.55);
      color: rgba(255,255,255,.98);
      border:1px solid rgba(255,255,255,.12);

      text-align:center;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      pointer-events:none;
    }
.uiBtn{
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      background: rgba(0,0,0,.22);
      color: var(--ink);
      padding:12px 12px;
      cursor:pointer;
      font-family: inherit;
      font-size:13px;
      font-weight:1000;
      border-radius:14px;
      touch-action: manipulation;
    }
    .uiBtn:hover{ outline:2px solid rgba(255,255,255,.18); background: rgba(255,255,255,.04); }
    .uiBtn.primary{
      border-color: rgba(255,220,120,.95);
      color: var(--gold);
    }
    .btnRow{
      display:flex;
      gap:10px;
      justify-content:flex-end;
      flex-wrap:wrap;
      margin-top:4px;
    }

    .achList{
      margin-top:10px;
      display:grid;
      gap:10px;
    }
    .achRow{
      display:grid;
      grid-template-columns: 42px 1fr;
      gap:10px;
      align-items:center;
      border:4px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      background: rgba(0,0,0,.22);
      border-radius:14px;
      padding:10px;
    }
    .achIcon{
      width:42px;
      height:42px;
      border-radius:12px;
      border:3px solid rgba(0,0,0,.55);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.08);
      display:grid;
      place-items:center;
      font-weight:1000;
      color: var(--gold);
      background: rgba(0,0,0,.22);
    }
    .achTitle{
      font-weight:1000;
      color: var(--ink);
      line-height:1.2;
    }
    .achDesc{
      margin-top:4px;
      font-size:12px;
      color: var(--muted);
      line-height:1.5;
    }
    .achRow.locked{
      opacity: .55;
      filter: grayscale(.2);
    }

  </style>
</head>
<body>
  <div class="frame pixel">
    <div class="battlefield" id="battlefield">
      <div class="bgFallback" id="bgFallback"></div>
      <img class="bgImg pixel" id="bgImg" alt="Stage background" />

      <div class="damageFlash" id="damageFlash"></div>

      <div class="laneLabel">Words</div>
      <div class="wordLane" id="wordLane"></div>

      <!-- Input is directly under the falling words -->
      <div class="inputBar" id="inputBar">
        <form id="answerForm" autocomplete="off">
          <div class="promptChar">&gt;</div>
          <input
            id="answerInput"
            type="text"
            placeholder="英語を入力… 例: taller / the tallest"
            autocomplete="off"
            autocapitalize="none"
            autocorrect="off"
            spellcheck="false"
            inputmode="text"
            enterkeyhint="done"
            disabled
          />
          <button type="submit" style="position:absolute; left:-9999px; width:1px; height:1px; opacity:0;">OK</button>
        </form>
      </div>

      <div class="bossWrap">
        <div class="bossInner">
          <div class="bossBubble" id="bossBubble"></div>

                    <div class="stage3Timer" id="stage3Timer">禁忌更新まで 4秒</div>

          <div class="stage4Timer" id="stage4Timer">切替まで 5秒</div>

          <div class="ex2Timer" id="ex2Timer">変化まで 5秒</div>
          <div class="ex2EndTimer" id="ex2EndTimer">残り --:--</div>

          <div class="ex4Timer" id="ex4Timer">残り --:--</div>

          <div class="stage5Timer" id="stage5Timer">残り --:--</div>



          <img class="bossImg pixel" id="bossImg" alt="Boss sprite" />
          <div class="bossFallback" id="bossFallback">
            Stage Boss<br>
            <span style="color:var(--muted); font-weight:700; font-size:12px;">(stage?_boss.webp を置く)</span>
          </div>
        </div>
      </div>

      <div class="overflowBadge" id="overflowBadge">OVERFLOW! 1 dmg/sec</div>

      <div class="overlay" id="overlay">
        <div class="overlayBox" role="dialog" aria-modal="true">
                    <h2 id="overlayTitle">MODE SELECT</h2>
          <p id="overlayDesc">モードを選んで開始</p>

          <div class="overlayChoices" id="overlayChoices"></div>

          <div class="overlayHint" id="overlayHint">▶ ボタンでモードを選択</div>
          <div class="countdown" id="countdownText"></div>
        </div>
      </div>
    </div>


      <div class="overlay" id="profileOverlay" aria-hidden="true">
        <div class="overlayBox" role="dialog" aria-modal="true">
          <h2 id="profileTitle">PROFILE</h2>
          <p id="profileDesc">初回はユーザー名とアイコンを設定してください。</p>

          <div class="profileCoinsRow">
            <span class="profileCoinsLabel">Coins</span>
            <b id="profileCoinsValue">0</b>
          </div>

          <div class="profileForm">
            <div>
              <div class="profileLabel">Name</div>
              <input class="profileInput" id="profileNameInput" type="text" maxlength="16" placeholder="Your name (max 16)" autocomplete="off" />
            </div>

            <div>
              <div class="profileLabel">Icon</div>
              <div class="iconGrid" id="profileIconGrid"></div>
            </div>

            <div class="btnRow">
              <button class="uiBtn" id="profileCancelBtn" type="button">Cancel</button>
              <button class="uiBtn primary" id="profileSaveBtn" type="button">Save</button>
            </div>

            <div class="overlayHint" id="profileHint"></div>
          </div>
        </div>
      </div>

      <div class="overlay" id="achOverlay" aria-hidden="true">
        <div class="overlayBox" role="dialog" aria-modal="true">
          <h2 id="achTitle">ACHIEVEMENTS</h2>
          <p class="muted" id="achDesc">達成した実績を確認できます。</p>

          <div class="achList" id="achList"></div>

          <div class="btnRow">
            <button class="uiBtn primary" id="achCloseBtn" type="button">Close</button>
          </div>
        </div>
      </div>

    <div class="uiRow">
      <div class="panel">
        <div class="panelHeader">
          <span class="playerHeaderWrap"><img id="playerIcon" class="playerIcon pixel" alt="icon" /><span class="playerMeta"><span class="playerNameRow"><b id="playerLabel">Player</b><span class="playerLevel muted" id="playerLevelText"></span></span><span class="playerExp muted" id="playerExpText"></span></span></span>
          <span class="muted">Commands</span>
        </div>
        <ul class="menuList">
<li class="menuItem" id="pauseCmd"><span class="arrow">▶</span><span id="pauseCmdText">Pause (ESC)</span></li>
<li class="menuItem" id="runCmd"><span class="arrow">▶</span><span>Run (Reset)</span></li>
        
          <li class="menuItem" id="profileCmd"><span class="arrow">▶</span><span>Profile</span></li>
          <li class="menuItem" id="achievementsCmd"><span class="arrow">▶</span><span>Achievements</span></li>
</ul>
      </div>

      <div class="panel">
        <div class="panelHeader">
          <span>Stage: <b id="stageName">-</b></span>
          <span>Boss: <b id="bossName">-</b></span>
        </div>

        <div class="msg" id="msgBox">
          <div>ルール：<span class="muted">日本語が落ちる → 英語をタイプして攻撃</span></div>
          <div class="muted">（オーバーフロー中は毎秒ダメージ）</div>
        </div>

        <div class="small">※ 大文字小文字は無視（the tallest / The Tallest OK）</div>
      </div>

      <div class="panel">
        <div class="panelHeader">
          <span>Status</span>
          <span>Miss: <b id="mistakesText">0</b></span>
        </div>

        <div class="statusList">
          <div class="statRow">
            <div class="name">Boss</div>
            <div class="bars">
              <div class="barLine bossHpLine" id="bossHpLine">
                <span>HP</span>
                <div class="meter" id="bossMeter"><div class="fillBoss" id="bossFill"></div></div>
                <span><b id="bossHpText">-</b></span>
              </div>
              <div class="barLine">
                <span>DMG</span>
                <div class="meter"><div class="fillAP" id="dmgFill"></div></div>
                <span><b id="hitDamageText">-</b></span>
              </div>
            </div>
          </div>

          <div class="statRow">
            <div class="name">Player</div>
            <div class="bars">
              <div class="barLine">
                <span>HP</span>
                <div class="meter"><div class="fillHP" id="playerFill"></div></div>
                <span><b id="playerHpText">-</b></span>
              </div>
            </div>
          </div>

          <div class="hpPips" id="hpPips" aria-label="HP pips"></div>

          <div class="small">
            Continues: <b id="continuesText">3</b>
          </div>

          <div class="small">
            Score (<b id="scoreModeLabel">Normal</b>): <b id="scoreText">0</b> /
            Best: <b id="bestScoreText">0</b><span class="muted" id="scorePenaltyText"></span>
          </div>

          <div class="bgmRow">
            <span>BGM:</span>
            <input id="bgmVol" type="range" min="0" max="100" value="35" />
            <span><b id="bgmVolText">35%</b></span>
            <button class="bgmBtn" id="bgmMuteBtn">MUTE</button>
          </div>
</div>
      </div>
    </div>
  </div>


  <!-- Intro start screen (shows before mode select) -->
  <!-- Drop-in assets (same folder as this HTML):
       - intro_locked_bg.webp
       - intro_unlocked_bg.webp
       - intro_master_bg.webp
       - intro_locked_bgm.m4a
       - intro_unlocked_bgm.m4a
       - intro_master_bgm.m4a
  -->
  <div class="introOverlay" id="introOverlay" aria-hidden="true">
    <div class="introBlackout" id="introBlackout"></div>
    <div class="introBg" id="introBg"></div>
    <div class="introShade"></div>

    <!-- Center profile display (startup screen) -->
    <div class="introProfileCard" id="introProfileCard" aria-hidden="true">
      <img class="introProfileIcon" id="introProfileIcon" src="icon01.webp" alt="icon" />
      <div class="introProfileText">
        <div class="introProfileName" id="introProfileName">Player</div>
        <div class="introProfileLevel" id="introProfileLevel">Lv.1</div>
        <div class="introProfileExp" id="introProfileExp">EXP: 0/20</div>
      </div>
    </div>

    <div class="introContent">
      <div class="introBadge" id="introBadge"></div>
      <button class="introStartBtn" id="introStartBtn" type="button">LOAD</button>
      <div class="introNote" id="introNote"></div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  const clamp = (v,a,b)=> Math.max(a, Math.min(b,v));
  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }
  async function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

function fitAnswerToRight(wordEl){
    try{
      const el = wordEl && (wordEl.el || wordEl);
      if(!el) return;

      const ans = el.querySelector(".answer");
      const right = el.querySelector(".right");
      if(!ans || !right) return;

      // Reset any previous fitting
      ans.style.fontSize = "";
      ans.style.transform = "";

      // Available width inside the right block
      const maxW = Math.max(60, right.clientWidth - 6);

      // Measure once; avoid repeated reflow loops
      const sw = ans.scrollWidth;

      if(sw > maxW){
        const scale = maxW / Math.max(1, sw);
        const clamped = Math.max(0.72, Math.min(1, scale));
        ans.style.transformOrigin = "right center";
        ans.style.transform = `scaleX(${clamped.toFixed(3)})`;
      }
    }catch(_){}
  }

  // ✅ VOCAB LIST
  const WORDS = [
    
    { prompt:"自転車", answer:"bike" },
    { prompt:"車", answer:"car" },
    { prompt:"電車", answer:"train" },
    { prompt:"男性", answer:"man" },
    { prompt:"女性", answer:"woman" },
    { prompt:"男の子", answer:"boy" },
    { prompt:"女の子", answer:"girl" },
    { prompt:"人々", answer:"people" },
    { prompt:"１月", answer:"January" },
    { prompt:"２月", answer:"February" },
    { prompt:"３月", answer:"March" },
    { prompt:"４月", answer:"April" },
    { prompt:"５月", answer:"May" },
    { prompt:"６月", answer:"June" },
    { prompt:"７月", answer:"July" },
    { prompt:"８月", answer:"August" },
    { prompt:"９月", answer:"September" },
    { prompt:"１０月", answer:"October" },
    { prompt:"１１月", answer:"November" },
    { prompt:"１２月", answer:"December" },
    { prompt:"月", answer:"moon" },
    { prompt:"太陽", answer:"sun" },
    { prompt:"海", answer:"sea" },
    { prompt:"湖", answer:"lake" },
    { prompt:"川", answer:"river" },
    { prompt:"木", answer:"tree" },
    { prompt:"山", answer:"mountain" },
    { prompt:"水", answer:"water" },
    { prompt:"家", answer:"house" },
    { prompt:"駅", answer:"station" },
    { prompt:"店", answer:"store" },
    { prompt:"公園", answer:"park" },
    { prompt:"窓", answer:"window" },
    { prompt:"ドア、戸", answer:"door" },
    { prompt:"ベッド", answer:"bed" },
    { prompt:"机", answer:"desk" },
    { prompt:"いす", answer:"chair" },
    { prompt:"テーブル", answer:"table" },
    { prompt:"本", answer:"book" },
    { prompt:"ノート", answer:"notebook" },
    { prompt:"えんぴつ", answer:"pencil" },
    { prompt:"を閉める", answer:"close" },
    { prompt:"住んでいる", answer:"live" },
    { prompt:"ほほえむ", answer:"smile" },
    { prompt:"を望む", answer:"hope" },
    { prompt:"練習する", answer:"practice" },
    { prompt:"をあける", answer:"open" },
    { prompt:"(...を)学ぶ", answer:"learn" },
    { prompt:"答え", answer:"answer" },
    { prompt:"をそうじする", answer:"clean" },

  ];

  const AUDIO = {
    victoryBgm: "victory_bgm.m4a",
    deathBgm: "death_bgm.m4a",
    bossHitSfx: "boss_hit.m4a",
    playerHitSfx: "player_hit.m4a",
    dialogueBgm: "dialogue_bgm.m4a",
    extraDialogueBgm: "ex_dialogue_bgm.m4a",
    extraVictoryBgm: "ex_victory_bgm.m4a",
    stage2FlashSfx: "stage2_flash_sfx.m4a",
    stage4FreezeSfx: "stage4_freeze_sfx.m4a",
  };

  let STAGES = [
    {
      stageName: "Stage 1",
      bossName: "Arc",
      bossDialogue: "I'm stronger than I look！",
      midFightDialogue: "Not yet!",
      bossMaxHp: 22,
      hitDamage: 1,
      spawnEveryMs: 2143,
      fallSpeedPxPerSec: 46,
      bgFile: "stage1_bg.webp",
      bossFile: "stage1_boss.webp",
      bossFile2: "stage1_boss2.webp",
      dialogueBgmFile: "dialogue_bgm.m4a",
      playBgmFile: "stage1_bgm.m4a",
      playBgmLoop: true,
      words: WORDS
    },
    {
      stageName: "Stage 2",
      bossName: "Pommi",
      bossDialogue: "3, 2, 1, BANG!",
      midFightDialogue: "Here, CATCH！",
      bossMaxHp: 25,
      hitDamage: 1,
      spawnEveryMs: 2041,
      fallSpeedPxPerSec: 49,
      bgFile: "stage2_bg.webp",
      bossFile: "stage2_boss.webp",
      bossFile2: "stage2_boss2.webp",
      dialogueBgmFile: "dialogue_bgm.m4a",
      playBgmFile: "stage2_bgm.m4a",
      playBgmLoop: true,
      words: WORDS
    },
    {
      stageName: "Stage 3",
      bossName: "Maestro",
      bossDialogue: "Let's do a little dance！",
      midFightDialogue: "Can you keep up?",
      bossMaxHp: 30,
      hitDamage: 1,
      spawnEveryMs: 1993,
      fallSpeedPxPerSec: 51,
      bgFile: "stage3_bg.webp",
      bossFile: "stage3_boss.webp",
      bossFile2: "stage3_boss2.webp",
      dialogueBgmFile: "dialogue_bgm.m4a",
      playBgmFile: "stage3_bgm.m4a",
      playBgmLoop: true,
      words: WORDS
    },
    {
      stageName: "Stage 4",
      bossName: "Izzy",
      bossDialogue: "I hope you have enough time.",
      midFightDialogue: "Don't blink!",
      bossMaxHp: 34,
      hitDamage: 1,
      spawnEveryMs: 2143,
      fallSpeedPxPerSec: 55,
      bgFile: "stage4_bg.webp",
      bossFile: "stage4_boss.webp",
      bossFile2: "stage4_boss2.webp",
      dialogueBgmFile: "dialogue_bgm.m4a",
      playBgmFile: "stage4_bgm.m4a",
      playBgmLoop: true,
      words: WORDS
    },
    {
      stageName: "Stage 5",
      bossName: "Frostbite",
      bossDialogue: "Does the cold bother you?",
      bossMaxHp: 28,
      hitDamage: 1,
      spawnEveryMs: 1643,
      fallSpeedPxPerSec: 65,
      bgFile: "stage5_bg.webp",
      bossFile: "stage5_boss.webp",
      bossFile2: "stage5_boss2.webp",
      bossFile3: "stage5_boss3.webp",
      dialogueBgmFile: "dialogue_bgm.m4a",
      playBgmFile: "stage5_bgm.m4a",
      playBgmLoop: true,
      words: WORDS
    }
  ];
// ---- Mode select (Normal / Extra) ----
const LS_KEY_NORMAL_CLEARED = "bossTyping_normalCleared_v1";
function loadNormalCleared(){
  try{ return localStorage.getItem(LS_KEY_NORMAL_CLEARED) === "1"; }catch(_){ return false; }
}
function saveNormalCleared(){
  try{ localStorage.setItem(LS_KEY_NORMAL_CLEARED, "1"); }catch(_){}
}



// Extra mode cleared (final extra stage beaten) -> unlock Master intro visuals/audio
const LS_KEY_EXTRA_CLEARED = "bossTyping_extraCleared_v1";
function loadExtraCleared(){
  try{ return localStorage.getItem(LS_KEY_EXTRA_CLEARED) === "1"; }catch(_){ return false; }
}
function saveExtraCleared(){
  try{ localStorage.setItem(LS_KEY_EXTRA_CLEARED, "1"); }catch(_){}
}


  // ---- Memory wipe cheat (persistent data reset) ----
function wipeGameMemory(){
  // Remove only this game's stored keys (do not touch other sites' data).
  try{
    const rm = [];
    for(let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      if(k && k.startsWith("bossTyping_")) rm.push(k);
    }
    rm.forEach(k => localStorage.removeItem(k));
  }catch(_){/* ignore */}
  try{
    const rm = [];
    for(let i=0;i<sessionStorage.length;i++){
      const k = sessionStorage.key(i);
      if(k && k.startsWith("bossTyping_")) rm.push(k);
    }
    rm.forEach(k => sessionStorage.removeItem(k));
  }catch(_){/* ignore */}

  // Reset in-memory mirrors (safe even if not yet initialized).
  try{ normalCleared = false; }catch(_){/* ignore */}
  try{ introIsUnlocked = false; }catch(_){/* ignore */}
  try{ debugMode = false; }catch(_){/* ignore */}
  try{ scoreNormal = 0; scoreExtra = 0; }catch(_){/* ignore */}
  try{ hiScoreNormal = 0; hiScoreExtra = 0; }catch(_){/* ignore */}
  try{ continuesUsedThisRun = 0; }catch(_){/* ignore */}
  try{ profile = null; }catch(_){/* ignore */}
  try{ renderProfileHeader(); }catch(_){/* ignore */}
}

// ---- Debug mode (playtesting) ----
const SS_KEY_DEBUG_MODE = "bossTyping_debugMode_v1";
function loadDebugMode(){
  try{ return sessionStorage.getItem(SS_KEY_DEBUG_MODE) === "1"; }catch(_){ return false; }
}
function saveDebugMode(on){
  try{ sessionStorage.setItem(SS_KEY_DEBUG_MODE, on ? "1" : "0"); }catch(_){}
}

// ---- High score (persistent) ----
// Separate best scores for Normal / Extra. (Current run score resets on restart.)
const LS_KEY_HISCORE_NORMAL = "bossTyping_hiScore_normal_v1";
const LS_KEY_HISCORE_EXTRA  = "bossTyping_hiScore_extra_v1";
const LS_KEY_EX2_TRAP_PHASE = "bossTyping_ex2TrapPhase_v1"; // "5" or "6"
const LS_KEY_EX2_RESUME_SNAPSHOT = "bossTyping_ex2ResumeSnapshot_v1"; // JSON snapshot for resuming EX2 after trap

function loadHighScore(mode){
  try{
    const k = (mode === "extra") ? LS_KEY_HISCORE_EXTRA : LS_KEY_HISCORE_NORMAL;
    const v = parseInt(localStorage.getItem(k) || "0", 10);
    return Number.isFinite(v) ? Math.max(0, v) : 0;
  }catch(_){ return 0; }
}
function saveHighScore(mode, val){
  try{
    const k = (mode === "extra") ? LS_KEY_HISCORE_EXTRA : LS_KEY_HISCORE_NORMAL;
    localStorage.setItem(k, String(Math.max(0, Math.trunc(val || 0))));
  }catch(_){}
}



function loadEx2TrapPhase(){
  try{ return localStorage.getItem(LS_KEY_EX2_TRAP_PHASE) || ""; }catch(_){ return ""; }
}
function saveEx2TrapPhase(v){
  try{
    if(!v){ localStorage.removeItem(LS_KEY_EX2_TRAP_PHASE); }
    else{ localStorage.setItem(LS_KEY_EX2_TRAP_PHASE, String(v)); }
  }catch(_){}
}

function loadEx2ResumeSnapshot(){
  try{
    const raw = localStorage.getItem(LS_KEY_EX2_RESUME_SNAPSHOT) || "";
    if(!raw) return null;
    const obj = JSON.parse(raw);
    return (obj && typeof obj === "object") ? obj : null;
  }catch(_){ return null; }
}
function saveEx2ResumeSnapshot(obj){
  try{
    if(!obj){ localStorage.removeItem(LS_KEY_EX2_RESUME_SNAPSHOT); return; }
    localStorage.setItem(LS_KEY_EX2_RESUME_SNAPSHOT, JSON.stringify(obj));
  }catch(_){}
}



const STAGES_NORMAL = STAGES;
// Extra mode: 2 stages. (Simplified)
const STAGES_EXTRA = STAGES_NORMAL.slice(0, 2).map((s, i) => ({
  ...s,
  stageName: `EX Stage ${i + 1}`,
  dialogueBgmFile: AUDIO.extraDialogueBgm,
}));

// Set to true to re-enable the old Extra-stage gimmicks (obscured/shuffle/ghost/invuln).
const EXTRA_SPECIAL_MECHANICS_ENABLED = false;

// Extra Stage boss images (put these files next to index.html)
// Extra Stage backgrounds (placeholders you can swap any time): ex1_bg.webp, ex2_bg.webp
// EX Stage 1
STAGES_EXTRA[0] = {
  ...STAGES_EXTRA[0],
  bgFile: "ex1_bg.webp",
  bossName: "Frostbite",
  bossDialogue: "Why are you here?!?",
  midFightDialogue: "I can't feel anything..",
  bossMaxHp: 34,
    spawnEveryMs: 1561,
  fallSpeedPxPerSec: 65,
  bossFile: "ex1_boss.webp",
  bossFile2: "ex1_boss_half.webp",
  playBgmFile: "ex1_bgm.m4a",
  playBgmLoop: true,
};
// EX Stage 2
STAGES_EXTRA[1] = {
  ...STAGES_EXTRA[1],
  bgFile: "ex2_bg.webp",
  bossName: "Twilight",
  bossDialogue: "I'll continue for you, Frostbite！",
  midFightDialogue: "You're getting very sleepy！",
  bossMaxHp: 30,
    spawnEveryMs: 1284,
  fallSpeedPxPerSec: 65,
  bossFile: "ex2_boss.webp",
  bossFile2: "ex2_boss_half.webp",
  bossFile3: "ex2_boss3.webp",
  playBgmFile: "ex2_bgm.m4a",
  playBgmLoop: false,
};


// Practice mode: Stage 1 baseline at 85% speed, boss invulnerable, infinite continues.
// Drop-in assets you can add later (same folder as index.html):
// - practice_bg.webp
// - practice_boss.webp (optional: practice_boss2.webp)
// - practice_bgm.m4a
const STAGES_PRACTICE = [
  (() => {
    const base = STAGES_NORMAL[0] || {};
    const baseSpawn = Number(base.spawnEveryMs) || 1500;
    const baseFall  = Number(base.fallSpeedPxPerSec) || 40;
    return {
      ...base,
      stageName: "Practice",
      bossName: "能海先生",
      bossDialogue: "しゃて！",
      midFightDialogue: "",
      // 85% fall speed; spawn rate reduced by an additional 50% (interval x2 vs prior practice):
      spawnEveryMs: Math.round((baseSpawn / 0.85) * 2),
      fallSpeedPxPerSec: baseFall * 0.85,

      // Practice-specific behavior flags:
      bossInvulnerable: true,
      infiniteContinues: true,

      // Customizable drop-in assets:
      bgFile: "practice_bg.webp",
      bossFile: "practice_boss.webp",
      bossFile2: "practice_boss2.webp",
      playBgmFile: "practice_bgm.m4a",
      playBgmLoop: true,

      words: base.words
    };
  })()
];


let currentMode = "normal"; // "normal" | "extra" | "practice"
let challengeNoEnglish = false; // Challenge Mode: Normal stages, English translations hidden
let debugMode = loadDebugMode();
let normalCleared = loadNormalCleared();
let extraCleared = loadExtraCleared();
let ex2TrapPhase = loadEx2TrapPhase();

function setMode(mode){
  // "challenge" behaves like Normal mode, but hides all English translations
  challengeNoEnglish = (mode === "challenge");

  currentMode = (mode === "extra") ? "extra" : ((mode === "practice") ? "practice" : "normal");
  STAGES = (currentMode === "extra") ? STAGES_EXTRA : ((currentMode === "practice") ? STAGES_PRACTICE : STAGES_NORMAL);
  updateUI();
}


  const BASE_PLAYER_MAX_HP = 10;
  const CHEAT_SKIP_STAGE5 = "657810";
  const DEBUG_MODE_CODE = "debugmode1";

  const CHEAT_MEMORY_WIPE = "memorywipe1";

  const CHEAT_MONEY = "moneymoneymoney";
  const CHEAT_MONEY_AMOUNT = 100000;
  const MAX_CONTINUES = 3;
  const CONTINUE_HP = 3;
  const CONTINUE_DECISION_SEC = 10;

  const wordLane = document.getElementById("wordLane");
  const overflowBadge = document.getElementById("overflowBadge");

  const bgImg = document.getElementById("bgImg");
  const bgFallback = document.getElementById("bgFallback");

  const bossImg = document.getElementById("bossImg");
  const bossFallback = document.getElementById("bossFallback");
  const bossBubble = document.getElementById("bossBubble");
  const stage5Timer = document.getElementById("stage5Timer");
  const stage3Timer = document.getElementById("stage3Timer");
  const stage4Timer = document.getElementById("stage4Timer");
  const ex2Timer = document.getElementById("ex2Timer");
  const ex2EndTimer = document.getElementById("ex2EndTimer");
  const ex4Timer = document.getElementById("ex4Timer");
  const ex4ResetScare = document.getElementById("ex4ResetScare");
  const bossMeter = document.getElementById("bossMeter");

  const damageFlash = document.getElementById("damageFlash");

  const overlay = document.getElementById("overlay");
  const overlayTitle = document.getElementById("overlayTitle");
  const overlayDesc = document.getElementById("overlayDesc");
  const overlayChoices = document.getElementById("overlayChoices");
  const overlayBox = overlay.querySelector(".overlayBox");
const overlayHint = document.getElementById("overlayHint");
  const countdownText = document.getElementById("countdownText");

  // ---- Profile / Achievements DOM ----
  const playerLabel = document.getElementById("playerLabel");
  const playerIconEl = document.getElementById("playerIcon");
  const playerLevelText = document.getElementById("playerLevelText");
  const playerExpText = document.getElementById("playerExpText");

  const profileOverlay = document.getElementById("profileOverlay");
  const profileTitle = document.getElementById("profileTitle");
  const profileDesc = document.getElementById("profileDesc");
  const profileNameInput = document.getElementById("profileNameInput");
  const profileIconGrid = document.getElementById("profileIconGrid");
  const profileSaveBtn = document.getElementById("profileSaveBtn");
  const profileCancelBtn = document.getElementById("profileCancelBtn");
  const profileHint = document.getElementById("profileHint");

  
  const profileCoinsValue = document.getElementById("profileCoinsValue");
const achOverlay = document.getElementById("achOverlay");
  const achTitle = document.getElementById("achTitle");
  const achDesc = document.getElementById("achDesc");
  const achList = document.getElementById("achList");
  const achCloseBtn = document.getElementById("achCloseBtn");

// ---- Profile / Level / Achievements (local, persistent; wiped by memorywipe1) ----
  const LS_KEY_PROFILE = "bossTyping_profile_v1";

  // Put your preset icon PNGs in the same folder as index.html (or change these paths).
  // Example files: icon01.webp, icon02.webp, ...
    const ICON_PRICE = 100000;

  // Put your preset icon PNGs in the same folder as index.html (or change these paths).
  // Example files: icon01.webp, icon02.webp, ...
  //  - icon01–03 are unlocked by default
  //  - all other icons cost ICON_PRICE coins (currency uses the same points you earn as score)
  const ICON_MAX = 9; // icon01.webp ... icon09.webp
  const PROFILE_ICON_PRESETS = Array.from({ length: ICON_MAX }, (_, idx) => {
    const n = idx + 1;
    const short = String(n).padStart(2, "0");
    const id = `icon${short}`;
    const starter = n <= 3; // auto-unlocked
    return { id, file: `${id}.webp`, short, price: starter ? 0 : ICON_PRICE, starter };
  });

  // You said you'll add achievements later — these are safe placeholders and also useful defaults.
  // You can freely edit/replace this list.
  const ACHIEVEMENT_DEFS = [
    { id:"normal_clear", title:"Normal Clear", desc:"Normal Mode をクリアする", icon:"N", unlockIcons:["icon05"] },
    { id:"extra_clear",  title:"Extra Clear",  desc:"Extra Mode をクリアする",  icon:"E", unlockIcons:["icon06"] },
    { id:"master_clear", title:"Master Clear", desc:"Normal + Extra を両方クリアする", icon:"M", unlockIcons:["icon07","icon08"] },

    // --- Challenge (hitless) achievements ---
    { id:"ch1_hitless", title:"Shield breaker", desc:"チャレンジステージ1をノーダメージでクリアする。", icon:"①" },
    { id:"ch2_hitless", title:"Boom!", desc:"チャレンジステージ2をノーダメージでクリアする。", icon:"②" },
    { id:"ch3_hitless", title:"In Fourths", desc:"チャレンジステージ3をノーダメージでクリアする。", icon:"③" },
    { id:"ch4_hitless", title:"Luna Clock", desc:"チャレンジステージ4をノーダメージでクリアする。", icon:"④" },
    { id:"ch5_hitless", title:"Yelena", desc:"チャレンジステージ5をノーダメージでクリアする。", icon:"⑤" },

    { id:"challenge_impossible", title:"Achieve the impossible", desc:"チャレンジステージ1〜5を、ノーダメージかつコンティニューなしで通しクリアする。", icon:"★" },
    { id:"all_achievements", title:"A perfect day", desc:"すべての実績を達成する。", icon:"✔" },
  ];

  // Level curve:
  // - You gain 1 XP per correct word.
  // - To level up from Lv.L -> Lv.(L+1), you need (20 + (L-1)) XP.
  //   Lv1->2:20, Lv2->3:21, Lv3->4:22, ...
  const XP_BASE = 20; // XP needed for Lv1->2

  // Total XP needed to *reach* a given level.
  // xpNeededToReachLevel(1)=0, xpNeededToReachLevel(2)=20, xpNeededToReachLevel(3)=41, ...
  const xpNeededToReachLevel = (level) => {
    const L = Math.max(1, Math.trunc(Number(level) || 1));
    if(L <= 1) return 0;
    const n = L - 1; // number of completed level-ups
    // Sum_{i=0..n-1} (XP_BASE + i)  = n*(2*XP_BASE + (n-1))/2
    return Math.trunc(n * (2*XP_BASE + (n - 1)) / 2);
  };

  // Inverse: find level from total XP.
  const levelFromXp = (xp) => {
    const T = Math.max(0, Math.trunc(Number(xp) || 0));
    // Solve T >= n*(2*XP_BASE + (n-1))/2  for n (where n=L-1).
    const b = 2*XP_BASE - 1;
    const n = Math.floor((-b + Math.sqrt(b*b + 8*T)) / 2);
    return Math.max(1, n + 1);
  };

  // XP needed to go from this level to the next.
  const xpToNextLevel = (level) => XP_BASE + (Math.max(1, Math.trunc(Number(level) || 1)) - 1);


  function createDefaultProfile(){
    return {
      v: 1,
      name: "",
      iconId: "icon01",
      xp: 0,
      achievements: [],
      coins: 0,
      unlockedIcons: ["icon01","icon02","icon03"],
      
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };
  }
  function normalizeProfile(p){
    const d = createDefaultProfile();
    const o = (p && typeof p === "object") ? p : {};
    const out = {
      v: 1,
      name: String(o.name ?? d.name).slice(0,16),
      iconId: String(o.iconId ?? d.iconId),
      xp: Math.max(0, Math.trunc(Number(o.xp ?? d.xp) || 0)),
      coins: Math.max(0, Math.trunc(Number(o.coins ?? d.coins) || 0)),
      achievements: Array.isArray(o.achievements) ? o.achievements.filter(x => typeof x === "string") : [],
      unlockedIcons: Array.isArray(o.unlockedIcons) ? o.unlockedIcons.filter(x => typeof x === "string") : [...d.unlockedIcons],
      createdAt: Math.trunc(Number(o.createdAt ?? d.createdAt) || Date.now()),
      updatedAt: Math.trunc(Number(o.updatedAt ?? d.updatedAt) || Date.now()),
    };
    for(const _id of ["icon01","icon02","icon03"]){ if(!out.unlockedIcons.includes(_id)) out.unlockedIcons.push(_id); }
    if(!PROFILE_ICON_PRESETS.some(x=>x.id===out.iconId)) out.iconId = "icon01";
    if(!(out.unlockedIcons || []).includes(out.iconId)) out.iconId = "icon01";
    return out;
  }
  function loadProfile(){
    try{
      const raw = localStorage.getItem(LS_KEY_PROFILE);
      if(!raw) return null;
      return normalizeProfile(JSON.parse(raw));
    }catch(_){
      return null;
    }
  }
  function saveProfile(p){
    try{
      localStorage.setItem(LS_KEY_PROFILE, JSON.stringify(p));
      return true;
    }catch(_){
      return false;
    }
  }

  let profile = loadProfile();

  const profileHas = (id) => !!(profile && Array.isArray(profile.achievements) && profile.achievements.includes(id));
  const getAchDef = (id) => ACHIEVEMENT_DEFS.find(a => a.id === id) || null;

  function fmtCoins(n){
    const v = Math.max(0, Math.trunc(Number(n) || 0));
    return String(v).replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }
  function getCoins(){
    return Math.max(0, Math.trunc(Number(profile && profile.coins) || 0));
  }
  function setCoins(v){
    if(!profile) return;
    profile.coins = Math.max(0, Math.trunc(Number(v) || 0));
    profile.updatedAt = Date.now();
    saveProfile(profile);
  }
  function addCoins(v){
    if(!profile) return;
    const add = Math.max(0, Math.trunc(Number(v) || 0));
    if(add <= 0) return;
    profile.coins = getCoins() + add;
    profile.updatedAt = Date.now();
    saveProfile(profile);
  }
  function spendCoins(cost){
    if(!profile) return false;
    const c = Math.max(0, Math.trunc(Number(cost) || 0));
    if(getCoins() < c) return false;
    profile.coins = getCoins() - c;
    profile.updatedAt = Date.now();
    saveProfile(profile);
    return true;
  }

  function ensureIconUnlocked(iconId){
    if(!profile) profile = createDefaultProfile();
    if(!profile.unlockedIcons.includes(iconId)){
      profile.unlockedIcons.push(iconId);
      profile.updatedAt = Date.now();
      saveProfile(profile);
      return true;
    }
    return false;
  }

  function unlockAchievement(id, silent=false){
    if(!id) return false;
    if(!profile) profile = createDefaultProfile();
    if(profileHas(id)) return false;

    profile.achievements.push(id);
    const def = getAchDef(id);
    if(def && Array.isArray(def.unlockIcons)){
      for(const iconId of def.unlockIcons){
}
    }
    profile.updatedAt = Date.now();
    saveProfile(profile);

    try{
      if(!silent){
        const label = def ? def.title : id;
        pushMsg(`🏅 Achievement unlocked: ${label}`, true);
      }
    }catch(_){/* ignore */}
    try{ renderProfileHeader(); }catch(_){/* ignore */}
    // Meta-achievement: unlock when all other achievements are complete
    if(id !== "all_achievements"){
      try{ checkAllAchievementsComplete(); }catch(_){/* ignore */}
    }
    return true;
  }

  function checkAllAchievementsComplete(){
    if(!profileReady()) return;
    const TARGET = "all_achievements";
    const have = new Set((profile && profile.achievements) ? profile.achievements : []);
    // Require every achievement except the meta one.
    const required = ACHIEVEMENT_DEFS
      .map(d => d && d.id)
      .filter(id => id && id !== TARGET);

    const complete = required.every(id => have.has(id));
    if(complete){
      // silent=true prevents an extra popup if you prefer; set to false if you want a toast.
      unlockAchievement(TARGET, false);
    }
  }

  // --- Challenge achievement checks ---
  function isChallengeMode(){
    return currentMode === "challenge";
  }

  function checkChallengeAchievementsAfterStageClear(){
    // Runs after a stage is cleared (before stageIndex increments / before victory).
    if(!isChallengeMode()) return;
    if(!profileReady()) return;

    // Hitless clears for Challenge stages 1–5
    if(damageTakenThisStage <= 0){
      const hitlessMap = {
        0: "ch1_hitless",
        1: "ch2_hitless",
        2: "ch3_hitless",
        3: "ch4_hitless",
        4: "ch5_hitless",
      };
      const achId = hitlessMap[stageIndex];
      if(achId) unlockAchievement(achId);
    }

    // "Achieve the impossible": Challenge 1–5 in one go, no damage, no continue.
    // Evaluate only on final stage (index 4), and only if this Challenge run is exactly 5 stages.
    const isFinalStage = (stageIndex === STAGES.length - 1);
    if(isFinalStage && STAGES.length === 5 && stageIndex === 4){
      if(damageTakenThisRun <= 0 && continuesUsedThisRun === 0){
        unlockAchievement("challenge_impossible");
      }
    }
  }


  function syncCoreAchievementsFromFlags(){
    // If the player already had clears saved from older builds, auto-grant these.
    try{
      const n = loadNormalCleared();
      const e = loadExtraCleared();
      if(n) unlockAchievement("normal_clear", true);
      if(e) unlockAchievement("extra_clear", true);
      if(n && e) unlockAchievement("master_clear", true);
    }catch(_){/* ignore */}

    try{ checkAllAchievementsComplete(); }catch(_){/* ignore */}
    }

  function addXp(amount){
    if(!profile) return;
    const a = Math.max(0, Math.trunc(Number(amount) || 0));
    if(a <= 0) return;

    const beforeLevel = levelFromXp(profile.xp);
    profile.xp = Math.max(0, profile.xp + a);
    const afterLevel = levelFromXp(profile.xp);

    profile.updatedAt = Date.now();
    saveProfile(profile);

    if(afterLevel > beforeLevel){
      try{ pushMsg(`⬆️ LEVEL UP! Lv.${afterLevel}`, true); }catch(_){/* ignore */}
    }
    try{ renderProfileHeader(); }catch(_){/* ignore */}
  }

  function profileReady(){
    return !!(profile && String(profile.name || "").trim().length > 0 && profile.iconId);
  }

  // ---- Profile modal ----
  let profileOverlayRequired = false;
  let profileOverlayOnDone = null;
  let selectedIconId = null;

  function setOverlayShow(el, show){
    if(!el) return;
    if(show){
      el.classList.add("show");
      el.setAttribute("aria-hidden", "false");
      el.style.cursor = "default";
    }else{
      el.classList.remove("show");
      el.setAttribute("aria-hidden", "true");
    }
  }
  function isOverlayShown(el){
    return !!(el && el.classList.contains("show"));
  }

  function renderIntroProfileCard(){
    if(!introProfileCard || !introProfileIcon || !introProfileName || !introProfileLevel) return;

    const p = profile || null;
    const nameRaw = p ? String(p.name || "").trim() : "";
    const name = nameRaw ? nameRaw : "Player";
    const lvl = p ? levelFromXp(p.xp) : 1;

    // Icon source
    const iconId = p ? (p.iconId || "icon01") : "icon01";
    const iconDef = PROFILE_ICON_PRESETS.find(x => x.id === iconId) || PROFILE_ICON_PRESETS[0];
    const src = iconDef ? iconDef.file : "icon01.webp";

    if(introProfileName.textContent !== name) introProfileName.textContent = name;
    const lvlText = `Lv.${lvl}`;
    if(introProfileLevel.textContent !== lvlText) introProfileLevel.textContent = lvlText;
    if(introProfileExp){
      const xp = Math.max(0, Math.trunc(Number(p && p.xp) || 0));
      const nextBase = xpNeededToReachLevel(lvl + 1);
      const xt = `EXP: ${xp}/${nextBase}`;
      if(introProfileExp.textContent !== xt) introProfileExp.textContent = xt;
    }
    if(introProfileIcon.getAttribute("src") !== src) introProfileIcon.setAttribute("src", src);

    // Show/hide: show if we have any profile object (or always show as default)
    introProfileCard.setAttribute("aria-hidden", "false");
  }


  function renderProfileHeader(){
    // Only update if needed (avoid extra DOM churn)
    if(!playerLabel) return;

    syncCoreAchievementsFromFlags();

    const p = profile;
    const name = p ? String(p.name || "").trim() : "";
    const lvl = p ? levelFromXp(p.xp) : 1;

    // Name + level
    const label = name ? name : "Player";
    const labelText = label;
    if(playerLabel.textContent !== labelText) playerLabel.textContent = labelText;

    if(playerLevelText){
      const lt = name ? `Lv.${lvl}` : "";
      if(playerLevelText.textContent !== lt) playerLevelText.textContent = lt;
    }

    // EXP progress (toward next level)
    if(playerExpText){
      if(p){
        const xp = Math.max(0, Math.trunc(Number(p && p.xp) || 0));
        const nextBase = xpNeededToReachLevel(lvl + 1);
        const xt = `EXP: ${xp}/${nextBase}`;
        if(playerExpText.textContent !== xt) playerExpText.textContent = xt;
      }else{
        if(playerExpText.textContent !== "") playerExpText.textContent = "";
      }
    }

    // Icon
    if(playerIconEl){
      const iconId = p ? p.iconId : "icon01";
      const iconDef = PROFILE_ICON_PRESETS.find(x => x.id === iconId) || PROFILE_ICON_PRESETS[0];
      const src = iconDef ? iconDef.file : "icon01.webp";
      if(playerIconEl.getAttribute("src") !== src) playerIconEl.setAttribute("src", src);
    }
    try{ renderIntroProfileCard(); }catch(_){/* ignore */}

  }

  function renderIconGrid(){
    if(!profileIconGrid) return;

    const work = profile || createDefaultProfile();
    const owned = new Set(work.unlockedIcons || []);
    const current = selectedIconId || work.iconId || "icon01";
    const coinsNow = Math.max(0, Math.trunc(Number(work.coins) || 0));
    if(profileCoinsValue) profileCoinsValue.textContent = fmtCoins(coinsNow);

    profileIconGrid.innerHTML = "";
    for(const icon of PROFILE_ICON_PRESETS){
      const price = Math.max(0, Math.trunc(Number(icon.price) || 0));
      const isOwned = owned.has(icon.id) || !!icon.starter;
      const canAfford = (price <= 0) || (coinsNow >= price);

      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "iconBtn" + (icon.id === current ? " selected" : "");
      btn.dataset.iconId = icon.id;

      // If not owned, show as locked but still clickable (click buys).
      if(!isOwned){
        btn.title = canAfford ? `Buy for ${fmtCoins(price)} coins` : `Need ${fmtCoins(price)} coins`;
        btn.style.opacity = canAfford ? "1" : ".55";
      }else{
        btn.title = icon.id;
      }

      const img = document.createElement("img");
      img.className = "iconImg pixel";
      img.alt = icon.id;
      img.src = icon.file;
      img.addEventListener("error", () => {
        try{
          img.remove();
          const fallback = document.createElement("div");
          fallback.textContent = icon.short || "??";
          fallback.style.fontWeight = "1000";
          fallback.style.color = "var(--gold)";
          fallback.style.fontSize = "16px";
          btn.appendChild(fallback);
        }catch(_){/* ignore */}
      });
      btn.appendChild(img);

      // Price / owned label (kept in-flow to avoid clipping into neighbors)
      if(!isOwned && price > 0){
        const tag = document.createElement("div");
        tag.className = "iconPriceTag";
        tag.textContent = `BUY ${fmtCoins(price)}`;
        btn.appendChild(tag);

        if(!canAfford){
          const note = document.createElement("div");
          note.className = "iconLockedNote";
          note.textContent = "Not enough";
          btn.appendChild(note);
        }
      }

      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        if(!profile) return;

        const ownedNow = new Set(profile.unlockedIcons || []);
        const alreadyOwned = ownedNow.has(icon.id) || !!icon.starter;

        if(alreadyOwned){
          selectedIconId = icon.id;
          renderIconGrid();
          return;
        }

        const cost = Math.max(0, Math.trunc(Number(icon.price) || 0));
        if(cost <= 0){
          // Free icon
          ensureIconUnlocked(icon.id);
          selectedIconId = icon.id;
          renderIconGrid();
          return;
        }

        if(!spendCoins(cost)){
          if(profileHint) profileHint.textContent = `Coins が足りません（必要: ${fmtCoins(cost)}）`;
          return;
        }

        // Mark owned + auto-select
        ensureIconUnlocked(icon.id);
        selectedIconId = icon.id;
        if(profileHint) profileHint.textContent = `購入しました！ (${fmtCoins(cost)} coins)`;
        renderIconGrid();
      });

      profileIconGrid.appendChild(btn);
    }
  }

function openProfileModal(required=false, onDone=null){
    if(!profile) profile = createDefaultProfile();

    profileOverlayRequired = !!required;
    profileOverlayOnDone = (typeof onDone === "function") ? onDone : null;

    if(profileTitle) profileTitle.textContent = required ? "CREATE PROFILE" : "PROFILE";
    if(profileDesc) profileDesc.textContent = required
      ? "初回はユーザー名とアイコンを設定してください"
      : "ユーザー名・アイコンを確認/変更できます。";

    if(profileCancelBtn) profileCancelBtn.style.display = required ? "none" : "";
    if(profileHint) profileHint.textContent = required ? "※ 設定しないと進めません" : "";

    if(profileNameInput){
      profileNameInput.value = String(profile.name || "");
      // Focus for convenience (desktop)
      try{ setTimeout(() => profileNameInput.focus(), 0); }catch(_){/* ignore */}
    }

    selectedIconId = profile.iconId || "icon01";
    
    try{ if(profileCoinsValue) profileCoinsValue.textContent = fmtCoins(getCoins()); }catch(_){/* ignore */}
    renderIconGrid();
    setOverlayShow(profileOverlay, true);
  }

  function closeProfileModal(){
    setOverlayShow(profileOverlay, false);
    profileOverlayRequired = false;
    profileOverlayOnDone = null;
  }

  function commitProfileFromModal(){
    if(!profile) profile = createDefaultProfile();

    const name = String(profileNameInput ? profileNameInput.value : "").trim();
    if(name.length <= 0){
      if(profileHint) profileHint.textContent = "Name を入力してください";
      return false;
    }
    if(name.length > 16){
      if(profileHint) profileHint.textContent = "Name は16文字以内です";
      return false;
    }

    // Ensure selected icon is selectable
    const iconId = String(selectedIconId || profile.iconId || "icon01");
        const owned = new Set(profile.unlockedIcons || []);
    const iconDef2 = PROFILE_ICON_PRESETS.find(x=>x.id===iconId);
    const isOwned = owned.has(iconId) || (iconDef2 && iconDef2.starter);
    if(!isOwned){
      if(profileHint) profileHint.textContent = "そのアイコンは購入してください";
      return false;
    }
const iconDef = PROFILE_ICON_PRESETS.find(x=>x.id===iconId) || PROFILE_ICON_PRESETS[0];
    // Save
    profile.name = name;
    profile.iconId = iconId;
    ensureIconUnlocked(iconId);

    profile.updatedAt = Date.now();
    saveProfile(profile);

    renderProfileHeader();

    const cb = profileOverlayOnDone;
    closeProfileModal();
    if(cb) cb();
    return true;
  }

  function openAchievementsModal(){
    syncCoreAchievementsFromFlags();
    if(achTitle) achTitle.textContent = "ACHIEVEMENTS";
    if(achDesc) achDesc.textContent = "達成した実績を確認できます。";

    if(achList){
      achList.innerHTML = "";
      if(!ACHIEVEMENT_DEFS.length){
        const d = document.createElement("div");
        d.className = "muted";
        d.textContent = "No achievements yet.";
        achList.appendChild(d);
      }else{
        for(const a of ACHIEVEMENT_DEFS){
          const unlocked = profileHas(a.id);
          const row = document.createElement("div");
          row.className = "achRow" + (unlocked ? "" : " locked");

          const ic = document.createElement("div");
          ic.className = "achIcon";
          ic.textContent = unlocked ? (a.icon || "★") : "？";

          const body = document.createElement("div");
          const t = document.createElement("div");
          t.className = "achTitle";
          t.textContent = unlocked ? a.title : "???";
          const d = document.createElement("div");
          d.className = "achDesc";
          d.textContent = unlocked ? a.desc : `LOCKED — ${a.desc}`;
          body.appendChild(t);
          body.appendChild(d);

          row.appendChild(ic);
          row.appendChild(body);
          achList.appendChild(row);
        }
      }
    }
    setOverlayShow(achOverlay, true);
  }
  function closeAchievementsModal(){
    setOverlayShow(achOverlay, false);
  }

  // Click outside to close (if allowed)
  if(profileOverlay){
    profileOverlay.addEventListener("click", (e) => {
      if(e.target !== profileOverlay) return;
      if(profileOverlayRequired) return;
      closeProfileModal();
    });
  }
  if(achOverlay){
    achOverlay.addEventListener("click", (e) => {
      if(e.target !== achOverlay) return;
      closeAchievementsModal();
    });
  }
  if(profileSaveBtn) profileSaveBtn.addEventListener("click", (e)=>{ e.stopPropagation(); commitProfileFromModal(); });
  if(profileCancelBtn) profileCancelBtn.addEventListener("click", (e)=>{ e.stopPropagation(); closeProfileModal(); });
  if(achCloseBtn) achCloseBtn.addEventListener("click", (e)=>{ e.stopPropagation(); closeAchievementsModal(); });

  // ESC should close these modals first (without pausing/resuming etc.)
  window.addEventListener("keydown", (e) => {
    if(e.key !== "Escape") return;
    if(isOverlayShown(profileOverlay)){
      if(!profileOverlayRequired){
        e.preventDefault(); e.stopPropagation();
        closeProfileModal();
      }
      return;
    }
    if(isOverlayShown(achOverlay)){
      e.preventDefault(); e.stopPropagation();
      closeAchievementsModal();
      return;
    }
  }, true);

  // Allow quick reset during non-typing overlay states (prevents the need for an on-overlay Reset button).
  window.addEventListener("keydown", (e) => {
    if(!(e.key === "r" || e.key === "R")) return;
    // Only when the main game overlay is shown (not Profile/Achievements) and we're not in Mode Select.
    if(!isOverlayShown(overlay)) return;
    if(isOverlayShown(profileOverlay) || isOverlayShown(achOverlay)) return;
    if(gameState === "modeselect") return;

    // These states are safe to reset from (no active typing input).
    const okStates = ["dialogue", "stageclear", "victory", "gameover", "paused", "continuePrompt"];
    if(!okStates.includes(gameState)) return;

    e.preventDefault();
    e.stopPropagation();
    resetGame();
  }, true);
  const stageNameEl = document.getElementById("stageName");
  const bossNameEl = document.getElementById("bossName");

  const bossFill = document.getElementById("bossFill");
  const bossHpText = document.getElementById("bossHpText");
  const ex4EyeBanner = document.getElementById("ex4EyeBanner");

  const hitDamageText = document.getElementById("hitDamageText");
  const dmgFill = document.getElementById("dmgFill");

  const playerFill = document.getElementById("playerFill");
  const playerHpText = document.getElementById("playerHpText");
  const mistakesText = document.getElementById("mistakesText");

  const continuesText = document.getElementById("continuesText");
  const scoreModeLabel = document.getElementById("scoreModeLabel");
  const scoreText = document.getElementById("scoreText");
  const bestScoreText = document.getElementById("bestScoreText");
  const scorePenaltyText = document.getElementById("scorePenaltyText");


  const msgBox = document.getElementById("msgBox");
  const answerForm = document.getElementById("answerForm");
  const answerInput = document.getElementById("answerInput");

  const hpPipsEl = document.getElementById("hpPips");

  const startCmd = document.getElementById("startCmd");
  const pauseCmd = document.getElementById("pauseCmd");
  const pauseCmdText = document.getElementById("pauseCmdText");
  const resetCmd = document.getElementById("resetCmd");
  const runCmd = document.getElementById("runCmd");
  const profileCmd = document.getElementById("profileCmd");
  const achievementsCmd = document.getElementById("achievementsCmd");

  const bgmVol = document.getElementById("bgmVol");
  const bgmVolText = document.getElementById("bgmVolText");
  const bgmMuteBtn = document.getElementById("bgmMuteBtn");

  function showOverlay(show){
    overlay.classList.toggle("show", show);
    // Ensure the overlay is always the top-most interactive layer.
    // (Some browsers create tricky stacking contexts with transformed elements.)
    const bf = document.getElementById("battlefield");
    if(bf) bf.classList.toggle("overlayOpen", !!show);
  }
  function setOverlayText(title, desc, hint){
    overlayTitle.textContent = title;
    overlayDesc.textContent = desc;
    overlayHint.textContent = hint;
    countdownText.textContent = "";
    overlayChoices.classList.remove("show");
    overlayChoices.innerHTML = "";
    if(overlayBox) overlayBox.classList.remove("debugSmall");
    overlay.style.cursor = "pointer";
  }
  function setOverlayTitleStageClear(stageName){
    overlayTitle.innerHTML = `<span class="stageClearSlide">${escapeHtml(stageName)} Clear</span>`;
  }

  function pushMsg(text, muted=false){
    const div = document.createElement("div");
    div.textContent = text;
    if(muted) div.className = "muted";
    msgBox.appendChild(div);
    while(msgBox.children.length > 8) msgBox.removeChild(msgBox.firstChild);
    msgBox.scrollTop = msgBox.scrollHeight;
  }

  function showStage5Timer(show){
    stage5Timer.classList.toggle("show", !!show);
  }

  function formatTime(sec){
    const s = Math.max(0, Math.ceil(sec));
    const m = Math.floor(s / 60);
    const ss = String(s % 60).padStart(2, "0");
    return `${m}:${ss}`;
  }
    let stage5TimerLastText = "";

  function updateStage5Timer(){
    // Stage 5 no longer uses a BGM-remaining timer.
    showStage5Timer(false);
  }

  let bossBubbleTimer = null;
  function showBossBubble(text, ms=4000){
    if(bossBubbleTimer){ clearTimeout(bossBubbleTimer); bossBubbleTimer = null; }
    bossBubble.textContent = text;
    bossBubble.classList.add("show");
    bossBubbleTimer = setTimeout(() => {
      bossBubble.classList.remove("show");
      bossBubble.textContent = "";
      bossBubbleTimer = null;
    }, ms);
  }
  function hideBossBubble(){
    if(bossBubbleTimer){ clearTimeout(bossBubbleTimer); bossBubbleTimer = null; }
    bossBubble.classList.remove("show");
    bossBubble.textContent = "";
  }


  

const bgm = new Audio();
  bgm.preload = "auto";
  bgm.loop = true;

  let currentBgm = "";
  let isMuted = false;
  let lastVol = 0.35;
  let audioUnlocked = false;

  let savedBgmState = null;
  function saveBgmState(){
    savedBgmState = {
      src: currentBgm || (bgm.currentSrc || ""),
      time: Number.isFinite(bgm.currentTime) ? bgm.currentTime : 0,
      loop: !!bgm.loop
    };
  }
  function restoreBgmState(){
    if(!savedBgmState || !savedBgmState.src) return;
    const {src, time, loop} = savedBgmState;
    setBgm(src, loop);
    try{ bgm.currentTime = Math.max(0, time || 0); }catch(_){}
    savedBgmState = null;
  }

  function pushAudioHintOnce(msg){
    pushMsg(msg || "⚠️ Safari/iOS：自動再生がブロックされる場合があります。音が出ない時はSTARTを押してからUNMUTEを押してください", true);
  }

  function setBgmVolume(v01){
    const v = Math.max(0, Math.min(1, v01));
    lastVol = v;
    // Always keep the real volume in sync; muting is handled via bgm.muted.
    bgm.volume = v;
    try{ bgm.muted = !!isMuted; }catch(_){/* ignore */}
    bgmVol.value = String(Math.round(v * 100));
    bgmVolText.textContent = `${Math.round(v * 100)}%`;
  }
  function toggleMute(){
    isMuted = !isMuted;
    try{ bgm.muted = !!isMuted; }catch(_){/* ignore */}
    bgm.volume = lastVol;
    bgmMuteBtn.textContent = isMuted ? "UNMUTE" : "MUTE";
    // Helpful on iOS/Safari: unmuting is a user gesture, so retry play.
    if(!isMuted) tryPlayBgm();
  }
  async function tryPlayBgm(){
    try{
      // If the track ended (non-loop), rewind so play() can restart.
      try{
        if(Number.isFinite(bgm.duration) && bgm.duration > 0){
          if(bgm.ended || bgm.currentTime >= bgm.duration - 0.05){
            bgm.currentTime = 0;
          }
        }
      }catch(_){/* ignore */}

      // Keep element mute state consistent with the UI state.
      try{ bgm.muted = !!isMuted; }catch(_){/* ignore */}
      if(!isMuted) bgm.volume = lastVol;

      const p = bgm.play();
      if(p && typeof p.catch === "function"){
        p.catch(() => {
          // Fallback: try muted autoplay (often allowed) so BGM can begin immediately.
          try{
            const prevUserMuted = isMuted;
            const prevMutedProp = bgm.muted;

            // Force muted playback and reflect it in UI so UNMUTE works.
            isMuted = true;
            bgmMuteBtn.textContent = "UNMUTE";
            bgm.muted = true;
            bgm.volume = lastVol;

            const p2 = bgm.play();
            if(p2 && typeof p2.catch === "function"){
              p2.catch(() => {
                // Restore previous state if even muted autoplay was blocked.
                isMuted = prevUserMuted;
                bgmMuteBtn.textContent = prevUserMuted ? "UNMUTE" : "MUTE";
                bgm.muted = prevMutedProp;
                if(!prevUserMuted) bgm.volume = lastVol;
                pushAudioHintOnce();
              });
            }else{
              // muted autoplay likely succeeded
              pushAudioHintOnce("🔇 自動再生がブロックされました（ミュートで再生中）。音を出すにはUNMUTEしてください");
            }
          }catch(_){
            pushAudioHintOnce();
          }
        });
      }
    }catch(_){
      pushAudioHintOnce();
    }
  }
  
  // iOS/iPad Safari sometimes treats later async BGM starts as "autoplay" and forces mute.
  // When we have a REAL user gesture (tap/click), use this helper to start BGM with sound.
  function tryPlayBgmFromGesture(){
    // Explicit user intent: default to unmuted.
    isMuted = false;
    bgmMuteBtn.textContent = "MUTE";
    try{ bgm.volume = lastVol; }catch(_){/* ignore */}

    // If the track ended (non-loop), rewind so play() can restart.
    try{
      if(Number.isFinite(bgm.duration) && bgm.duration > 0){
        if(bgm.ended || bgm.currentTime >= bgm.duration - 0.05){
          bgm.currentTime = 0;
        }
      }
    }catch(_){/* ignore */}

    // Workaround: start muted, then immediately unmute in the same gesture tick.
    // This improves the success rate of audible playback on iOS Safari.
    try{
      try{ bgm.muted = true; }catch(_){/* ignore */}
      const p = bgm.play();
      try{ bgm.muted = false; }catch(_){/* ignore */}
      if(p && typeof p.catch === "function"){
        p.catch(() => {
          pushAudioHintOnce("⚠️ iPad/Safari：音が出ない時は、もう一度画面をタップしてからMUTE/UNMUTEを押してください");
        });
      }
    }catch(_){
      pushAudioHintOnce("⚠️ iPad/Safari：音が出ない時は、もう一度画面をタップしてからMUTE/UNMUTEを押してください");
    }
  }


function setBgm(src, loop=true, autoplay=true){
    bgm.loop = !!loop;
    if(!src){ stopBgm(); return; }
    if(currentBgm !== src){
      currentBgm = src;
      bgm.src = src;
      bgm.currentTime = 0;
      try{ bgm.load(); }catch(_){/* ignore */}
    }
    if(autoplay) tryPlayBgm();
  }
  function stopBgm(){
    currentBgm = "";
    bgm.pause();
    bgm.removeAttribute("src");
    bgm.load();
  }

  // Clear Extra Stage 2 only when its stage BGM finishes (boss takes no damage).
  // NOTE: We guard by (1) stage, (2) gameState, and (3) currentBgm matching the stage BGM.
  bgm.addEventListener("ended", () => {
    try{
      if(!ex2ClearOnBgmEndActive) return;
      if(!isExtraStage2()) return;
      if(gameState !== "playing") return;
      if(!ex2ClearOnBgmEndSrc || currentBgm !== ex2ClearOnBgmEndSrc) return;

      ex2ClearOnBgmEndActive = false; // prevent double-fire
      ex2ClearOnBgmEndSrc = "";

      onBossDefeated();
    }catch(_){/* ignore */}
  });

  // ---- Intro start screen (pre-menu) ----
  // Replace these drop-in filenames anytime you want by overwriting the files in the same folder.
  const INTRO_BG_LOCKED = "intro_locked_bg.webp";
  const INTRO_BG_UNLOCKED = "intro_unlocked_bg.webp";
  const INTRO_BG_MASTER = "intro_master_bg.webp";
  const INTRO_BGM_LOCKED = "intro_locked_bgm.m4a";
  const INTRO_BGM_UNLOCKED = "intro_unlocked_bgm.m4a";
  const INTRO_BGM_MASTER = "intro_master_bgm.m4a";
  const INTRO_FAKE_LOAD_MS = 5000;

  const introOverlay = document.getElementById("introOverlay");
  const introBg = document.getElementById("introBg");
  const introBadge = document.getElementById("introBadge");
  const introStartBtn = document.getElementById("introStartBtn");
  const introNote = document.getElementById("introNote");

  // Center profile display on startup screen
  const introProfileCard = document.getElementById("introProfileCard");
  const introProfileIcon = document.getElementById("introProfileIcon");
  const introProfileName = document.getElementById("introProfileName");
  const introProfileLevel = document.getElementById("introProfileLevel");
  const introProfileExp = document.getElementById("introProfileExp");

  let introTimer = null;
  let introState = "idle"; // "idle" -> "loading" -> "ready"
  let introShownOnce = false;
  let introBgmErrorHandler = null;

  // ---- Intro unlocked BG glitch reveal ----
  let introIsUnlocked = false;

  let introRevealActive = false;
  let introRevealRAF = null;
  let introPulseTimer = null;
  let introPulseCleanupTimer = null;
  let introBaseOpacity = 1; // eased 0..1

  function stopIntroBgGlitch(){
    introRevealActive = false;
    if(introRevealRAF){ cancelAnimationFrame(introRevealRAF); introRevealRAF = null; }
    if(introPulseTimer){ clearTimeout(introPulseTimer); introPulseTimer = null; }
    if(introPulseCleanupTimer){ clearTimeout(introPulseCleanupTimer); introPulseCleanupTimer = null; }
    introBg.classList.remove("introGlitching", "introGlitchPulse");
    introBg.style.removeProperty("--gX");
    introBg.style.removeProperty("--gY");
    introBg.style.removeProperty("--gSkew");
    introBg.style.removeProperty("--gShiftX");
  }

  function setIntroBgHidden(hidden){
    introBg.classList.toggle("introHidden", !!hidden);
    if(hidden){
      introBaseOpacity = 0;
      introBg.style.opacity = "0";
    }else{
      introBaseOpacity = 1;
      introBg.style.opacity = "1";
    }
  }

  function startUnlockedIntroBgReveal(){
    // Smooth reveal for unlocked/master intro background (no glitch).
    stopIntroBgGlitch();
    introRevealActive = true;

    introBg.classList.remove("introHidden");
    introBg.classList.remove("introGlitching", "introGlitchPulse");

    const start = performance.now();
    const dur = INTRO_FAKE_LOAD_MS;

    const step = () => {
      if(!introRevealActive) return;
      const p = clamp((performance.now() - start) / dur, 0, 1);
      // ease-in so it starts "invisible"
      const eased = Math.pow(p, 1.18);
      introBaseOpacity = eased;
      introBg.style.opacity = String(clamp(eased, 0, 1));

      if(p < 1){
        introRevealRAF = requestAnimationFrame(step);
      }else{
        introRevealRAF = null;
      }
    };
    introRevealRAF = requestAnimationFrame(step);
  }

  function finishUnlockedIntroBgReveal(){
    // Called when fake loading finishes (~5s)
    stopIntroBgGlitch();
    introBg.classList.remove("introHidden");
    introBg.style.opacity = "1";
  }


  function setIntroState(state){
    introState = state;
    try{ introOverlay.dataset.state = state; }catch(_){ }
    if(state === "idle"){
      introStartBtn.disabled = false;
      introStartBtn.textContent = "LOAD";
      introNote.textContent = introNote.textContent || "Press LOAD";
    }else if(state === "loading"){
      introStartBtn.disabled = true;
      introStartBtn.textContent = "LOADING…";
    }else if(state === "ready"){
      introStartBtn.disabled = false;
      introStartBtn.textContent = "START";
      introNote.textContent = "Ready.";
    }
  }

  function showIntroStartScreen(force=false){
    if(introShownOnce && !force) return;
    introShownOnce = true;

    setIntroState("idle");

    const normalDone = loadNormalCleared();
    const extraDone = loadExtraCleared();
    const masterDone = (normalDone && extraDone);

    introIsUnlocked = !!normalDone; // any Normal clear unlocks the "LOAD->reveal" behavior
    stopIntroBgGlitch();
    // Unlocked/Master intro bg starts invisible until LOAD is pressed.
    setIntroBgHidden(introIsUnlocked);


    const bgFile = masterDone ? INTRO_BG_MASTER : (normalDone ? INTRO_BG_UNLOCKED : INTRO_BG_LOCKED);
    const bgmFile = masterDone ? INTRO_BGM_MASTER : (normalDone ? INTRO_BGM_UNLOCKED : INTRO_BGM_LOCKED);
// Background: set directly (more robust) + keep CSS var for fallback.
    introBg.style.setProperty("--introBg", `url("${bgFile}")`);
    introBg.style.backgroundImage = `url("${bgFile}")`;

    // Badge text (optional)
    introBadge.textContent = masterDone ? "English RPG typing game — ALL CLEAR" : (normalDone ? "English RPG typing game" : "English typing game");

    // Diagnostics / guidance
    introNote.textContent = "Press LOAD";
    try{ renderIntroProfileCard(); }catch(_){/* ignore */}
// Preload background to detect missing file / wrong path
    try{
      const img = new Image();
      img.onload = () => {
        // background loaded
      };
      img.onerror = () => {
        introNote.textContent = `⚠️ Background not found: ${bgFile} (check filename + case, and that it is in the same folder as index.html)`;
      };
      img.src = `${bgFile}?v=${Date.now()}`; // cache-bust for testing
    }catch(_){}

    introOverlay.classList.add("show");
    introOverlay.setAttribute("aria-hidden", "false");

    // Audio: set the track now, but DO NOT start until the user presses LOAD.
    stopBgm();
    setBgm(bgmFile, true, false);
    if(introBgmErrorHandler){
      bgm.removeEventListener("error", introBgmErrorHandler);
      introBgmErrorHandler = null;
    }

    const onBgmError = () => {
      if(currentBgm === bgmFile){
        introNote.textContent = `⚠️ BGM not found: ${bgmFile} (check filename + case, and that it is in the same folder as index.html)`;
      }
      bgm.removeEventListener("error", onBgmError);
    };
    introBgmErrorHandler = onBgmError;
    bgm.addEventListener("error", onBgmError);
  }
  function hideIntroStartScreen(){
    if(introTimer) clearTimeout(introTimer);
    introTimer = null;

    stopIntroBgGlitch();

    introOverlay.classList.remove("show");
    introOverlay.setAttribute("aria-hidden", "true");

    // Stop intro music. (Stage/Dialogue BGMs will start normally once the game begins.)
    stopBgm();
  }
  introStartBtn.addEventListener("click", (e) => {
    e.stopPropagation();

    // Any button press counts as a user gesture: force an audible start on iPad/Safari.
    try{ tryPlayBgmFromGesture(); }catch(_){
      try{ bgm.muted = false; }catch(_){/* ignore */}
      tryPlayBgm();
    }
if(introState === "idle"){
      // Fake loading for ~5 seconds
      // Unlocked intro background: glitch-reveal while "loading".
      if(introIsUnlocked){ startUnlockedIntroBgReveal(); }

      setIntroState("loading");
      const start = performance.now();
      if(introTimer) clearTimeout(introTimer);
      introTimer = setInterval(() => {
        const t = performance.now() - start;
        const pct = clamp((t / INTRO_FAKE_LOAD_MS) * 100, 0, 100);
        introNote.textContent = `Loading… ${Math.floor(pct)}%`;
        if(t >= INTRO_FAKE_LOAD_MS){
          clearInterval(introTimer);
          introTimer = null;
          setIntroState("ready");
          if(introIsUnlocked){ finishUnlockedIntroBgReveal(); }
        }
      }, 120);
      return;
    }

    if(introState === "ready"){
      hideIntroStartScreen();
      // Move the player directly to mode select ("the actual game")
      try{ showModeSelectScreen(); }catch(_){ /* ignore */ }
    }
  });



  const sfxPool = { bossHit: [], bossIdx: 0, playerHit: [], playerIdx: 0, stage4Freeze: [], stage4Idx: 0 };
  function initSfxPool(){
    const n = 4;

    // Boss hit
    sfxPool.bossHit = Array.from({length:n}, () => {
      const a = new Audio(AUDIO.bossHitSfx);
      a.preload = "auto";
      a.volume = 0.55;
      return a;
    });

    // Player damage
    sfxPool.playerHit = Array.from({length:n}, () => {
      const a = new Audio(AUDIO.playerHitSfx);
      a.preload = "auto";
      a.volume = 0.70;
      return a;
    });

    // Stage 4 time-freeze (Normal Stage 4)
    sfxPool.stage4Freeze = Array.from({length:2}, () => {
      const a = new Audio(AUDIO.stage4FreezeSfx);
      a.preload = "auto";
      a.volume = 0.75;
      return a;
    });
  }
  function playBossHitSfx(){
    const arr = sfxPool.bossHit;
    if(!arr || arr.length === 0) return;
    const a = arr[sfxPool.bossIdx % arr.length];
    sfxPool.bossIdx++;
    try{ a.currentTime = 0; a.play().catch(()=>{}); }catch(_){}
  }

  function playPlayerHitSfx(){
    const arr = sfxPool.playerHit;
    if(!arr || arr.length === 0) return;
    const a = arr[sfxPool.playerIdx % arr.length];
    sfxPool.playerIdx++;
    try{ a.currentTime = 0; a.play().catch(()=>{}); }catch(_){}
  }

  function playStage4FreezeSfx(){
    const arr = sfxPool.stage4Freeze;
    if(!arr || arr.length === 0) return;
    const a = arr[sfxPool.stage4Idx % arr.length];
    sfxPool.stage4Idx++;
    try{ a.currentTime = 0; a.play().catch(()=>{}); }catch(_){}
  }



  function startStage2FlashSfx(wordObj){
    if(!wordObj) return;
    if(wordObj.s2FlashSfx) return; // already playing/created
    try{
      const a = new Audio(AUDIO.stage2FlashSfx);
      a.preload = "auto";
      a.loop = true;
      a.volume = 0.55;
      wordObj.s2FlashSfx = a;
      a.play().catch(()=>{});
    }catch(_){}
  }

  function stopStage2FlashSfx(wordObj){
    if(!wordObj) return;
    const a = wordObj.s2FlashSfx;
    if(!a) return;
    try{
      a.pause();
      a.currentTime = 0;
    }catch(_){}
    wordObj.s2FlashSfx = null;
  }



  function unlockAudioOnce(){
    if(audioUnlocked) return;
    audioUnlocked = true;
    // No auto-audio warmup here: intro BGM must only start when the user presses LOAD.
  }

function showModeSelectScreen(){

  // Ensure the player has created a profile first (first-time login flow)
  if(!profileReady()){
    openProfileModal(true, () => { showModeSelectScreen(); });
    return;
  }
  renderProfileHeader();

  normalCleared = loadNormalCleared();

  gameState = "modeselect";
  setInputsEnabled(false);

  showOverlay(true);
  // Play menu BGM on mode select
  setBgm("dialogue_bgm.m4a", true, true);

  if(overlayBox) overlayBox.classList.remove("debugSmall");
  overlay.style.cursor = "default";

  overlayTitle.textContent = "MODE SELECT";
  overlayDesc.textContent = "モードを選んでください";
  overlayHint.textContent = (normalCleared && extraCleared)
    ? "Extra Mode クリア済み！"
    : (normalCleared
        ? "Extra Mode 解放済み！"
        : "Normal Mode をクリアすると Extra Mode が解放されます");

  countdownText.textContent = "";
  overlayChoices.classList.add("show");
  overlayChoices.innerHTML = "";

  const addBtn = ({title, desc, note, disabled, onClick}) => {
    const b = document.createElement("div");
    b.className = "choiceBtn" + (disabled ? " disabled" : "");
    if(disabled){
      b.style.opacity = "0.45";
      b.style.pointerEvents = "none";
      b.style.filter = "grayscale(.12)";
    }
    b.innerHTML = `
      <div class="title">${escapeHtml(title)}</div>
      <div class="desc">${escapeHtml(desc)}</div>
      ${note ? `<div class="note">${escapeHtml(note)}</div>` : "" }
    `;
    if(!disabled){
      b.addEventListener("click", (e) => { e.stopPropagation(); onClick(); });
    }
    overlayChoices.appendChild(b);
  };


  addBtn({
    title: "Practice Mode",
    desc: "エンドレス練習",
    note: "いつでもOK",
    disabled: false,
    onClick: () => {
      setMode("practice");
      showOverlay(false);
      startGame();
    }
  });

  addBtn({
    title: "Normal Mode",
    desc: "現在のゲーム（5ステージ）",
    note: normalCleared ? "Cleared ✓（Extra が選べます）" : "Clear すると Extra 解放",
    disabled: false,
    onClick: () => {
      setMode("normal");
      showOverlay(false);
      startGame();
    }
  });


  addBtn({
    title: "Challenge Mode",
    desc: "Normal 5ステージ（英訳なし）",
    note: normalCleared ? "Unlocked ✓" : "LOCKED: Normal をクリアしてね",
    disabled: !normalCleared,
    onClick: () => {
      setMode("challenge");
      showOverlay(false);
      startGame();
    }
  });

  addBtn({
    title: "Extra Mode",
    desc: "2ステージ（Normal クリア後に解放）",
    note: normalCleared ? "Unlocked ✓" : "LOCKED: Normal をクリアしてね",
    disabled: !normalCleared,
    onClick: () => {
      setMode("extra");
      showOverlay(false);
      startGame();
    }
  });

  // --- Profile / Achievements (moved here per request) ---
  const playerLv = profile ? levelFromXp(profile.xp || 0) : 1;
  let achUnlocked = 0;
  try{
    for(const a of ACHIEVEMENT_DEFS){ if(profileHas(a.id)) achUnlocked++; }
  }catch(_){}

  addBtn({
    title: "Profile",
    desc: "ユーザー名・アイコン・レベル",
    note: profile ? `${(profile.name || "-")} · Lv ${playerLv}` : "Not set",
    disabled: false,
    onClick: () => {
      // Re-render mode select after save so notes update cleanly
      openProfileModal(false, () => { showModeSelectScreen(); });
    }
  });

  addBtn({
    title: "Achievements",
    desc: "実績を確認",
    note: (ACHIEVEMENT_DEFS && ACHIEVEMENT_DEFS.length) ? `${achUnlocked}/${ACHIEVEMENT_DEFS.length} unlocked` : "Coming soon",
    disabled: false,
    onClick: () => {
      openAchievementsModal();
    }
  });

}
// ---- Game state ----


  // ---- Async UI flow cancellation ----
  // Prevents countdown/dialogue/etc. from resuming after Reset/Run.
  let uiFlowToken = 0;
  let uiFlowCleanups = [];
  function addUiFlowCleanup(fn){
    uiFlowCleanups.push(fn);
    return () => {
      const i = uiFlowCleanups.indexOf(fn);
      if(i >= 0) uiFlowCleanups.splice(i, 1);
    };
  }
  function cancelUiFlow(){
    uiFlowToken++;
    const toRun = uiFlowCleanups.slice();
    uiFlowCleanups.length = 0;
    for(const fn of toRun){
      try{ fn(); }catch(_){/* ignore */}
    }
    return uiFlowToken;
  }
  function isUiFlow(t){ return t === uiFlowToken; }

  let gameState = "idle";
  let stageIndex = 0;

  // Only true immediately after the player's FIRST ever clear of Stage 5 (Normal).
  // Used to send them back to the start menu on the next Reset from the victory screen.
  let victoryResetToStartMenuOnce = false;

  let bossHp = 0;
  let bossMaxHp = 0;

  // For non-Stage5 bosses: swap to phase 2 art when HP drops below half (used by Extra stages)
  let bossVariantPhase = 1;
  let baseHitDamage = 1;

  // Extra Stage 1: phase state (1 or 2)
  let ex1Phase = 1;

  let playerMaxHp = BASE_PLAYER_MAX_HP;
  let playerHp = BASE_PLAYER_MAX_HP;
  let mistakes = 0;

  let continuesLeft = (currentMode === "practice") ? Infinity : MAX_CONTINUES;
  let continuePromptUntilMs = 0;
  let continueListeners = null;
  let pauseListeners = null;
  let pausedBgmState = null;

  // ---- Scoring ----
  // Normal and Extra have separate scores (no carryover between modes).
  // Score carries across stages within the same run/mode.
  let scoreNormal = 0;
  let scoreExtra = 0;
  let scorePractice = 0;

  let hiScoreNormal = loadHighScore("normal");
  let hiScoreExtra  = loadHighScore("extra");
  let hiScorePractice = 0; // session-only (not saved)
  let continuesUsedThisRun = 0; // affects future points: ×(0.8^continuesUsed)
  let damageTakenThisStage = 0;
  let damageTakenThisRun = 0;

  function getActiveScore(){
    if(currentMode === "extra") return scoreExtra;
    if(currentMode === "practice") return scorePractice;
    return scoreNormal;
  }
  function setActiveScore(v){
    v = Math.max(0, Math.trunc(Number(v) || 0));
    if(currentMode === "extra") scoreExtra = v;
    else if(currentMode === "practice") scorePractice = v;
    else scoreNormal = v;
  }
  function getActiveHiScore(){
    if(currentMode === "extra") return hiScoreExtra;
    if(currentMode === "practice") return hiScorePractice;
    return hiScoreNormal;
  }
  function setActiveHiScore(v){
    v = Math.max(0, Math.trunc(Number(v) || 0));
    if(currentMode === "extra"){
      hiScoreExtra = v; saveHighScore("extra", v);
    }else if(currentMode === "practice"){
      // Practice scores are session-only (do not write to localStorage)
      hiScorePractice = v;
    }else{
      hiScoreNormal = v; saveHighScore("normal", v);
    }
  }
  function scorePenaltyMultiplier(){
    if(currentMode === "practice") return 1;
    // 0 continues => ×1.00, 1 => ×0.80, 2 => ×0.64, 3 => ×0.512 ...
    return Math.pow(0.8, Math.max(0, continuesUsedThisRun|0));
  }

  function scoreModeMultiplier(){
    // Challenge or Extra: ×2 score
    return (currentMode === "extra" || !!challengeNoEnglish) ? 2 : 1;
  }
  function resetRunScoring(){
// Reset current mode run score + penalty.
    setActiveScore(0);
    continuesUsedThisRun = 0;
    damageTakenThisRun = 0;
    damageTakenThisStage = 0;

  }
  function resetAllRunScoring(){
    scoreNormal = 0;
    scoreExtra = 0;
    continuesUsedThisRun = 0;
  }
  function addScore(points){
    const p = Math.max(0, Math.trunc(Number(points) || 0));
    if(p <= 0) return;
    const ns = getActiveScore() + p;
    setActiveScore(ns);
    if(ns > getActiveHiScore()) setActiveHiScore(ns);
  
    // Coins use the same points you earn as score (persisted). Practice does not earn coins.
    try{ if(currentMode !== "practice" && profileReady && profileReady()) addCoins(p); }catch(_){/* ignore */}
}

  function countEnglishLetters(s){
    // Count A–Z letters only (spaces/punct ignored). "the tallest" => 10
    const norm = normalizeAnswer(s || "");
    const letters = norm.replace(/[^a-z]/g, "");
    return Math.max(0, letters.length);
  }
  function basePointsForAnswer(answer){
    // Simple length-based scoring: 10 points per letter (min 10).
    const n = countEnglishLetters(answer);
    return Math.max(10, n * 10);
  }
  function fallingHeightMultiplier(y){
    // Higher on screen => more points (range ~1.2x .. 2.0x)
    const h = laneHeight();
    const maxY = Math.max(1, h - 30);
    const progress = clamp(y / maxY, 0, 1);     // 0 top, 1 bottom
    const height01 = 1 - progress;              // 1 top, 0 bottom
    return 1.2 + 0.8 * height01;                // 2.0 top, 1.2 bottom
  }
  function calcWordScore(word){
    // EX2 Phase 5 trap: do not award points in the fake instance.
    try{ if(isEx2TrapPhase5 && isEx2TrapPhase5()) return 0; }catch(_){/* ignore */}
    const base = basePointsForAnswer(word?.answer || "");
    const posMult = (word?.state === "falling") ? fallingHeightMultiplier(word.y || 0) : 1.0;
    const pen = scorePenaltyMultiplier();
    const modeMult = scoreModeMultiplier();
    return Math.max(1, Math.round(base * posMult * pen * modeMult));
  }


  let wordsOnField = [];
  

  let restackDirty = false;
  function showDebugStagePicker(){
  const prevState = gameState;
  const wasPlaying = (prevState === "playing");

  if(wasPlaying){
    pauseStageClock();
    showStage5Timer(false);
  }

  gameState = "debugselect";
  setInputsEnabled(false);

  showOverlay(true);
  overlay.style.cursor = "default";
  if(overlayBox) overlayBox.classList.add("debugSmall");

  overlayTitle.textContent = "DEBUG";
  overlayDesc.textContent = "";
  overlayHint.textContent = "";
  countdownText.textContent = "";

  overlayChoices.classList.add("show");
  overlayChoices.innerHTML = "";

  const grid = document.createElement("div");
  grid.className = "debugGrid";
  overlayChoices.appendChild(grid);

  const cleanup = () => {
    overlayChoices.innerHTML = "";
    overlayChoices.classList.remove("show");
    if(overlayBox) overlayBox.classList.remove("debugSmall");
    overlay.removeEventListener("click", onOverlayClick);
    window.removeEventListener("keydown", onKeyDown);
  };

  const exitBack = () => {
    cleanup();
    if(wasPlaying){
      showOverlay(false);
      gameState = "playing";
      setInputsEnabled(true);
      resumeStageClock();
      updateUI();
    }else{
      showModeSelectScreen();
    }
  };

  const onOverlayClick = (e) => {
    if(e.target === overlay) exitBack();
  };

  const onKeyDown = (e) => {
    if(e.key === "Escape") exitBack();
  };

  overlay.addEventListener("click", onOverlayClick);
  window.addEventListener("keydown", onKeyDown);

  const jumpTo = (mode, idx) => {
    cleanup();
    // startStage handles its own overlay / countdown
    setMode(mode);
    startStage(idx);
  };

  const addBtn = (label, mode, idx) => {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "debugStageBtn";
    btn.textContent = label;
    btn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      jumpTo(mode, idx);
    });
    grid.appendChild(btn);
  };

  // Buttons: Normal 1-5, Extra 1-2
  for(let i=0;i<STAGES_NORMAL.length;i++){
    addBtn(`N${i+1}`, "normal", i);
  }
  for(let i=0;i<STAGES_EXTRA.length;i++){
    addBtn(`EX${i+1}`, "extra", i);
  }
}

async function debugJumpTo(mode, idx){
  cleanupContinueListeners();
  setMode(mode);
  resetAllRunScoring();

  // Reset run state (similar to startGame)
  resetField();
  hideBossBubble();
  showStage5Timer(false);

  stageIndex = clamp(idx, 0, Math.max(0, STAGES.length - 1));
  mistakes = 0;
  continuesLeft = (currentMode === "practice") ? Infinity : MAX_CONTINUES;
  playerMaxHp = BASE_PLAYER_MAX_HP;
  playerHp = playerMaxHp;

  resumeStageClock();
  showOverlay(false);
  await startStage(idx);
}


  let nextWordId = 1;

  let lastTs = 0;

  // Prevent huge dt spikes after tab/app is backgrounded.
  document.addEventListener("visibilitychange", () => {
    if(!document.hidden) lastTs = 0;
  });

  let overflow = false;
  let overflowAcc = 0;

  let stagePlayStartMs = 0;
  let stagePausedTotalMs = 0;
  let stagePauseStartMs = null;

  let spawnAccMs = 0;
  let autoSpawnEnabled = true; // can be disabled for the EX2 Phase 5 wake-up sequence

  let spawnCountThisStage = 0;
  let midFightBubbleShown = false;

// Normal Stage 3 state (timer-based forbidden selection)
// Every 4 seconds, re-pick 1/3 of currently spawned words (falling + landed) as "forbidden".
// Forbidden words can land/stack normally; typing them damages the player and does not damage the boss.
const S3_FORBIDDEN_CYCLE_SEC = 4;
let s3CycleLeftSec = 0;
let s3ForbiddenIds = new Set();
let s3HalfSpeedRandomized = false; // when boss HP drops below half (apply to existing words once)

// Normal Stage 4 state (cycle timer that periodically unifies all words)
  let stage4CycleLeftSec = 0;
  let stage4CycleIntervalSec = 5;
  const STAGE4_FREEZE_SEC = 2;
  let stage4FreezeLeftSec = 0;
  let stage4FreezeTarget = null; // {prompt, answer}
  let stage4FreezeTimeouts = [];
  let stage4SubmitBlockedThisFreeze = false;

  let stage5Phase = 1;
  let stage5EndedHandled = false;
  let stage5Phase2At = null;
  let stage5Phase3At = null;

  // Stage 5 (Normal) Phase 3 ramp: on each boss hit, slightly increase spawn rate + fall speed.
  let s5p3SpawnMs = null;
  let s5p3FallSpeed = null;
  let bossNormalSrc = "";

  function setInputsEnabled(enabled){
    answerInput.disabled = !enabled;
    if(enabled){
      answerInput.focus();
    }else{
      answerInput.blur();
      answerInput.value = "";
    }
  }

  // Like setInputsEnabled(), but does NOT clear the current text.
  // (Useful for Pause: keep what the user was typing.)
  function setInputsEnabledSoft(enabled){
    answerInput.disabled = !enabled;
    if(enabled){
      answerInput.focus();
    }else{
      answerInput.blur();
    }
  }

  function renderHpPips(){
    // PERF: Build pip elements once per max HP, then just toggle the "on" class.
    if(playerMaxHp !== hpPipMax){
      hpPipMax = playerMaxHp;
      hpPipEls = [];
      hpPipsEl.textContent = "";
      const frag = document.createDocumentFragment();
      for(let i=0;i<hpPipMax;i++){
        const pip = document.createElement("span");
        pip.className = "pip";
        hpPipEls.push(pip);
        frag.appendChild(pip);
      }
      hpPipsEl.appendChild(frag);
    }
    for(let i=0;i<hpPipEls.length;i++){
      hpPipEls[i].classList.toggle("on", i < playerHp);
    }
  }

  // PERF: UI updates are comparatively expensive. Cache last-rendered values to avoid
  // rewriting DOM on every animation frame.
  let hpPipEls = [];
  let hpPipMax = -1;

  const uiCache = {
    stageName: null,
    bossName: null,
    bossHpStr: null,
    bossFillW: null,
    effectiveHit: null,
    dmgFillW: null,
    playerHpStr: null,
    playerFillW: null,
    mistakes: null,
    continuesLeft: null,
    overflow: null,
    bossInv: null,
    scoreMode: null,
    scoreStr: null,
    bestScoreStr: null,
    penaltyStr: null,
  };

  const UI_TICK_MS = 50; // ~20fps is plenty for text/UI, reduces jank on mobile.
  let nextUiTickAt = 0;
function updatePauseCmdUI(){
  if(!pauseCmd || !pauseCmdText) return;

  let label = (gameState === "paused") ? "Resume (ESC)" : "Pause (ESC)";
  let disabled = false;

  if(gameState === "playing"){
    if(isExtraStage2()){
      disabled = true;
      label = "Pause (N/A in EX2)";
    }
  }else if(gameState === "paused"){
    disabled = false;
  }else{
    disabled = true;
    label = isExtraStage2() ? "Pause (N/A in EX2)" : "Pause";
  }

  pauseCmd.classList.toggle("disabled", disabled);
    pauseCmd.classList.toggle("crossedOut", isExtraStage2());
  pauseCmdText.textContent = label;
}

  function updateUIThrottled(){
    const now = nowMs();
    if(now < nextUiTickAt) return;
    nextUiTickAt = now + UI_TICK_MS;
    updateUI();
  }

function updateUI(){
    const stage = STAGES[stageIndex] || null;


    // Practice Mode: hide the confusing "Start（モード選択）" command (it doesn't work during play anyway)
    if(startCmd){
      startCmd.style.display = (currentMode === "practice") ? "none" : "";
    }
    const stageName = stage ? stage.stageName : "-";
    if(stageName !== uiCache.stageName){
      uiCache.stageName = stageName;
      stageNameEl.textContent = stageName;
    }

    const bossName = stage ? stage.bossName : "-";
    if(bossName !== uiCache.bossName){
      uiCache.bossName = bossName;
      bossNameEl.textContent = bossName;
    }

    // EX4: cover boss HP with eye banner (HP line only)
    if(ex4EyeBanner){
      const showEye = (currentMode === "extra" && stageIndex === 3 && gameState === "playing");
      ex4EyeBanner.style.opacity = showEye ? "1" : "0";
    }

    const bossHpStr = `${bossHp}/${bossMaxHp}`;
    if(bossHpStr !== uiCache.bossHpStr){
      uiCache.bossHpStr = bossHpStr;
      bossHpText.textContent = bossHpStr;
    }

    const effectiveHit = baseHitDamage;
    if(effectiveHit !== uiCache.effectiveHit){
      uiCache.effectiveHit = effectiveHit;
      hitDamageText.textContent = String(effectiveHit);
      const dmgW = `${(clamp(effectiveHit/5,0,1) * 100).toFixed(1)}%`;
      if(dmgW !== uiCache.dmgFillW){
        uiCache.dmgFillW = dmgW;
        dmgFill.style.width = dmgW;
      }
    }

    const bossW = `${((bossMaxHp ? clamp(bossHp/bossMaxHp,0,1) : 0) * 100).toFixed(1)}%`;
    if(bossW !== uiCache.bossFillW){
      uiCache.bossFillW = bossW;
      bossFill.style.width = bossW;
    }

    const playerHpStr = `${playerHp}/${playerMaxHp}`;
    if(playerHpStr !== uiCache.playerHpStr){
      uiCache.playerHpStr = playerHpStr;
      playerHpText.textContent = playerHpStr;
    }

    const playerW = `${(clamp(playerHp/playerMaxHp,0,1) * 100).toFixed(1)}%`;
    if(playerW !== uiCache.playerFillW){
      uiCache.playerFillW = playerW;
      playerFill.style.width = playerW;
    }

    if(mistakes !== uiCache.mistakes){
      uiCache.mistakes = mistakes;
      mistakesText.textContent = String(mistakes);
    }
    if(continuesLeft !== uiCache.continuesLeft){
      uiCache.continuesLeft = continuesLeft;
      continuesText.textContent = (currentMode === "practice" || continuesLeft === Infinity) ? "∞" : String(continuesLeft);
    }

    if(overflow !== uiCache.overflow){
      uiCache.overflow = overflow;
      overflowBadge.classList.toggle("show", overflow);
    }

    const bossInv = !!(stage && stage.bossInvulnerable);
    if(bossInv !== uiCache.bossInv){
      uiCache.bossInv = bossInv;
      if(bossMeter) bossMeter.classList.toggle("invuln", bossInv);
    }

    // ---- Score UI ----
    const modeLabel = (currentMode === "extra") ? "Extra" : ((currentMode === "practice") ? "Practice" : (challengeNoEnglish ? "Challenge" : "Normal"));
    if(scoreModeLabel && modeLabel !== uiCache.scoreMode){
      uiCache.scoreMode = modeLabel;
      scoreModeLabel.textContent = modeLabel;
    }

    const scoreStr = String(getActiveScore());
    if(scoreText && scoreStr !== uiCache.scoreStr){
      uiCache.scoreStr = scoreStr;
      scoreText.textContent = scoreStr;
    }

    const bestStr = String(getActiveHiScore());
    if(bestScoreText && bestStr !== uiCache.bestScoreStr){
      uiCache.bestScoreStr = bestStr;
      bestScoreText.textContent = bestStr;
    }

    const modeMult = scoreModeMultiplier();
    const multStr = (modeMult !== 1) ? ` / Mode ×${modeMult}` : "";
    const penStr = multStr + ((continuesUsedThisRun > 0) ? ` / Penalty ×${scorePenaltyMultiplier().toFixed(2)}` : "");
    if(scorePenaltyText && penStr !== uiCache.penaltyStr){
      uiCache.penaltyStr = penStr;
      scorePenaltyText.textContent = penStr;
    }

    updatePauseCmdUI();
    renderHpPips();
  }

  function flashPlayerDamage(){
    damageFlash.classList.remove("show");
    void damageFlash.offsetWidth;
    damageFlash.classList.add("show");
  }

  function resetField(opts = {}){
    const preservePermafrost = !!opts.preservePermafrost;

    if(!preservePermafrost){
      for(const w of wordsOnField){
        // Stop any per-word looping SFX before removing the DOM node.
        try{ stopStage2FlashSfx(w); }catch(_){/* ignore */}
        try{ w && w.el && w.el.remove(); }catch(_){}
      }
      wordsOnField = [];
    }else{
      const keep = [];
      for(const w of wordsOnField){
        // Stop any per-word looping SFX before either keeping or removing.
        try{ stopStage2FlashSfx(w); }catch(_){/* ignore */}
        if(w && w.s5Permafrost){
          keep.push(w);
        }else{
          try{ w && w.el && w.el.remove(); }catch(_){}
        }
      }
      wordsOnField = keep;
      restackLanded();
    }

    overflow = false;
    overflowAcc = 0;
  }

function laneHeight(){ return wordLane.clientHeight; }
  function laneCapacity(){ return Math.floor(laneHeight() / 30); }
  function landedWords(){ return wordsOnField.filter(w => w.state === "landed"); }

  // PERF: Use a CSS variable + translate3d to move words without triggering layout.
  function setWordY(el, y){
    el.style.setProperty("--y", `${y}px`);
    // Make "ghosting past each other" visually obvious: lower words render above higher words.
    el.style.zIndex = String(1000 + Math.round(y));
  }


  function restackLanded(){
    const h = laneHeight();
    const landed = landedWords().sort((a,b)=> b.y - a.y);
    for(let i=0;i<landed.length;i++){
      const y = h - 30 * (i+1);
      landed[i].y = y;
      setWordY(landed[i].el, y);
    }
    // NOTE: overflow + UI are handled in tick() for consistency/perf
  }

  function pickStageWord(){
    const stage = STAGES[stageIndex];
    const list = (stage && stage.words) ? stage.words : [];
    if(!list.length) return null;

    // Guard: skip accidental header rows like "Japanese    English"
    // and also skip empty/invalid entries.
    const isBad = (p, a) => {
      const pp = String(p ?? "").trim();
      const aa = String(a ?? "").trim();
      if(!pp || !aa) return true;
      const pL = pp.toLowerCase();
      const aL = aa.toLowerCase();

      // Common header / meta rows
      if((pL === "japanese" && aL === "english") || (pL === "english" && aL === "japanese")) return true;
      if((pp === "日本語" && aL === "japanese") || (pp === "英語" && aL === "english")) return true;

      return false;
    };

    for(let tries=0; tries<30; tries++){
      const w = list[Math.floor(Math.random() * list.length)];
      if(!w) continue;
      if(isBad(w.prompt, w.answer)) continue;
      return { prompt: w.prompt, answer: w.answer };
    }

    // Fallback: just return something rather than crashing
    const w = list[0];
    return w ? { prompt: w.prompt, answer: w.answer } : null;
  }

  // (Extra Stage 1 unique mechanics removed)


  function makeUnreadableAnswer(original){
    // Keep it unreadable, but compact so long JP prompts don\'t get squeezed.
    return "■".repeat(3);
  }
// ---- Normal Stage 1 mechanic: highlighted words require two correct entries ----
function isNormalStage1(){
  return currentMode === "normal" && stageIndex === 0;
}
function stage1HighlightFrequency(){
  if(!isNormalStage1()) return 0;
  // EX2 trap: wake-up waves should never be highlighted (single-clear only)
  if(isEx2TrapActive() && ex2WakeUpActive) return 0;
  // "boss hp drops below half" => strictly below half
  return (bossHp < (bossMaxHp / 2)) ? 3 : 4;
}




// ---- Normal Stage 2: highlight + flash timeout ----
function isNormalStage2(){
  return currentMode === "normal" && stageIndex === 1;
}
function stage2HighlightFrequency(){
  if(!isNormalStage2()) return 0;
  // After boss HP drops below half: 3 -> 2
  return (bossHp < (bossMaxHp / 2)) ? 2 : 3;
}
const STAGE2_FLASH_WINDOW_SEC = 3;

// ---- Normal Stage 3: timer-based forbidden selection + variable fall speed after half ----
function isNormalStage3(){
  return currentMode === "normal" && stageIndex === 2;
}
function stage3RandomFallMult(){
  // Gentle randomness (noticeable but still playable): 0.65–1.50
  return 0.65 + Math.random() * 0.85;
}
function stage3SetWordForbidden(w, on){
  if(!w) return;
  w.s3Forbidden = !!on;

  // Forbidden words must collide/stack normally (do not treat them as ghost words).
  if(on) w.ex3Ghost = false;

  try{
    if(w.el) w.el.classList.toggle("s3Forbidden", !!on);
  }catch(_){/* ignore */}
}
function stage3ClearForbidden(){
  if(!s3ForbiddenIds || s3ForbiddenIds.size === 0) return;
  for(const id of Array.from(s3ForbiddenIds)){
    const w = wordsOnField.find(x => x && x.id === id);
    if(w) stage3SetWordForbidden(w, false);
  }
  s3ForbiddenIds.clear();
}
function stage3PickForbiddenNow(){
  if(!isNormalStage3() || gameState !== "playing") return;

  // Deselect previous set, then pick a fresh set.
  stage3ClearForbidden();

  const candidates = wordsOnField.filter(w => w && (w.state === "falling" || w.state === "landed"));
  const n = candidates.length;
  if(n <= 0) return;

  // 1/3 of spawned words (minimum 1 if there is at least 1 word)
  let k = Math.floor(n / 3);
  if(k < 1) k = 1;

  // Sample k unique words (partial Fisher-Yates)
  for(let i=0;i<k;i++){
    const j = i + Math.floor(Math.random() * (n - i));
    const tmp = candidates[i];
    candidates[i] = candidates[j];
    candidates[j] = tmp;

    const w = candidates[i];
    if(!w) continue;
    stage3SetWordForbidden(w, true);
    s3ForbiddenIds.add(w.id);
  }
}
function stage3InitForbiddenCycle(){
  // Timer starts immediately, but selection happens only when it reaches 0.
  stage3ClearForbidden();
  s3CycleLeftSec = isNormalStage3() ? S3_FORBIDDEN_CYCLE_SEC : 0;
}
function stage3UpdateCycle(dt){
  if(!isNormalStage3() || gameState !== "playing") return;

  s3CycleLeftSec -= dt;
  while(s3CycleLeftSec <= 0){
    stage3PickForbiddenNow();
    s3CycleLeftSec += S3_FORBIDDEN_CYCLE_SEC;
  }
}

// ---- Normal Stage 4: periodic "all words become the same word" timer ----
function isNormalStage4(){
  return currentMode === "normal" && stageIndex === 3;
}
function stage4CycleSeconds(){
  if(!isNormalStage4()) return 0;
  // After boss HP drops below half: 5s -> 3s
  return (bossHp < (bossMaxHp / 2)) ? 3 : 5;
}
function stage4InitCycleTimer(){
  if(!isNormalStage4()) return;
  stage4CycleIntervalSec = stage4CycleSeconds() || 5;
  stage4CycleLeftSec = stage4CycleIntervalSec;
  // Reset any pending freeze/switch work
  stage4FreezeLeftSec = 0;
  stage4FreezeTarget = null;
  for(const t of stage4FreezeTimeouts){ try{ clearTimeout(t); }catch(_){/*ignore*/} }
  stage4FreezeTimeouts = [];
}

function stage4SwapAllWordsToSameRandom(){
  if(!isNormalStage4() || gameState !== "playing") return;
  const pick = pickStageWord();
  if(!pick) return;
  const {prompt, answer} = pick;

  for(const w of wordsOnField){
    if(!w) continue;

    w.prompt = prompt;
    w.answer = answer;
    w.answerNorm = normalizeAnswer(answer);

    // Ensure the answer is readable in Normal Stage 4
    w.hidePromptWhileFalling = !!challengeNoEnglish;
    try{ w.el && w.el.classList.toggle("obscured", !!challengeNoEnglish); }catch(_){/* ignore */}

    try{ if(w.promptEl) w.promptEl.textContent = prompt; }catch(_){/* ignore */}
    try{ if(w.answerEl) w.answerEl.textContent = (challengeNoEnglish ? makeUnreadableAnswer(answer) : answer); }catch(_){/* ignore */}
  }
}
function stage4IsFrozen(){
  return stage4FreezeLeftSec > 0;
}
function stage4ClearFreezeTimeouts(){
  for(const t of stage4FreezeTimeouts){ try{ clearTimeout(t); }catch(_){/* ignore */} }
  stage4FreezeTimeouts = [];
}
function stage4ForceSwapWord(w, prompt, answer){
  if(!w) return;
  w.prompt = prompt;
  w.answer = answer;
  w.answerNorm = normalizeAnswer(answer);
  // Ensure the answer is readable in Normal Stage 4
  w.hidePromptWhileFalling = !!challengeNoEnglish;
  try{ w.el && w.el.classList.toggle("obscured", !!challengeNoEnglish); }catch(_){/* ignore */}
  try{ if(w.promptEl) w.promptEl.textContent = prompt; }catch(_){/* ignore */}
  try{ if(w.answerEl) w.answerEl.textContent = (challengeNoEnglish ? makeUnreadableAnswer(answer) : answer); }catch(_){/* ignore */}
}
function stage4SwapWordWithFx(w, prompt, answer){
  if(!w || !w.el) return;
  try{ w.el.classList.add('s4Switching'); }catch(_){/* ignore */}
  const t = setTimeout(() => {
    // Word might have been cleared during the freeze
    if(!w || !wordsOnField || !wordsOnField.includes(w)) return;
    stage4ForceSwapWord(w, prompt, answer);
    try{ w.el && w.el.classList.remove('s4Switching'); }catch(_){/* ignore */}
  }, 120);
  stage4FreezeTimeouts.push(t);
}
function stage4StartFreezeSwitch(){
  if(!isNormalStage4() || gameState !== 'playing') return;
  if(stage4IsFrozen()) return;
  const interval = stage4CycleSeconds() || 5;
  stage4CycleIntervalSec = interval;
  stage4CycleLeftSec = interval; // timer restarts but won't tick during the freeze

  const pick = pickStageWord();
  if(!pick) return;
  stage4FreezeTarget = {prompt: pick.prompt, answer: pick.answer};

  stage4ClearFreezeTimeouts();
  stage4FreezeLeftSec = STAGE4_FREEZE_SEC;
  stage4SubmitBlockedThisFreeze = false;


  // SFX when the time-freeze starts
  playStage4FreezeSfx();
  // Individually transition words over the freeze window
  const list = wordsOnField ? wordsOnField.slice() : [];
  // Fisher-Yates shuffle for random order
  for(let i=list.length-1;i>0;i--){
    const j = (Math.random() * (i+1)) | 0;
    const tmp = list[i]; list[i] = list[j]; list[j] = tmp;
  }
  const n = list.length;
  if(n){
    const windowMs = Math.max(50, (STAGE4_FREEZE_SEC * 1000) - 200);
    const step = windowMs / n;
    for(let i=0;i<n;i++){
      const w = list[i];
      if(!w) continue;
      const delay = Math.max(0, Math.floor(i * step));
      const to = setTimeout(() => {
        if(!stage4FreezeTarget) return;
        stage4SwapWordWithFx(w, stage4FreezeTarget.prompt, stage4FreezeTarget.answer);
      }, delay);
      stage4FreezeTimeouts.push(to);
    }
  }
}
function stage4UpdateFreeze(dtReal){
  // If we leave Stage 4 or stop playing, cancel everything.
  if(!(isNormalStage4() && gameState === 'playing')){
    if(stage4FreezeLeftSec > 0 || stage4FreezeTimeouts.length){
      stage4FreezeLeftSec = 0;
      stage4FreezeTarget = null;
      stage4ClearFreezeTimeouts();
    }
    return;
  }
  if(stage4FreezeLeftSec <= 0) return;
  stage4FreezeLeftSec -= dtReal;
  if(stage4FreezeLeftSec <= 0){
    stage4FreezeLeftSec = 0;
    // Ensure every remaining word is unified at the end of the freeze.
    if(stage4FreezeTarget){
      for(const w of wordsOnField){
        if(!w) continue;
        stage4ForceSwapWord(w, stage4FreezeTarget.prompt, stage4FreezeTarget.answer);
        try{ w.el && w.el.classList.remove('s4Switching'); }catch(_){/* ignore */}
      }
    }
    stage4FreezeTarget = null;
    stage4ClearFreezeTimeouts();
    // If boss HP crossed half during the freeze, reset the interval accordingly.
    stage4CycleIntervalSec = stage4CycleSeconds() || stage4CycleIntervalSec || 5;
    stage4CycleLeftSec = stage4CycleIntervalSec;
  }
}

function stage4UpdateCycle(dt){
  if(!isNormalStage4() || gameState !== 'playing') return;

  // While the world is frozen (switch animation), the cycle timer does not tick.
  if(stage4IsFrozen()) return;

  const interval = stage4CycleSeconds() || 5;

  // If the interval changed (half HP), clamp remaining time to the new interval.
  if(interval !== stage4CycleIntervalSec){
    stage4CycleIntervalSec = interval;
    stage4CycleLeftSec = Math.min(stage4CycleLeftSec, interval);
  }

  stage4CycleLeftSec -= dt;

  if(stage4CycleLeftSec <= 0){
    stage4StartFreezeSwitch();
  }
}


  // Normal Stage 4: UI 
  // Normal Stage 3: countdown (until the next forbidden re-pick)
  let stage3TimerLastText = "";
  function showStage3Timer(show){
    if(!stage3Timer) return;
    stage3Timer.classList.toggle("show", !!show);
  }
  function updateStage3Timer(){
    if(!(gameState === "playing" && isNormalStage3())){
      showStage3Timer(false);
      stage3TimerLastText = "";
      return;
    }
    showStage3Timer(true);
    const left = Math.max(0, s3CycleLeftSec || 0);
    const txt = `禁忌更新まで ${Math.ceil(left)}秒`;
    if(txt !== stage3TimerLastText){
      stage3TimerLastText = txt;
      stage3Timer.textContent = txt;
    }
  }

// countdown (until the next full-field switch)
  let stage4TimerLastText = "";
  function showStage4Timer(show){
    if(!stage4Timer) return;
    stage4Timer.classList.toggle("show", !!show);
  }
  function updateStage4Timer(){
    if(!(gameState === 'playing' && isNormalStage4())){
      showStage4Timer(false);
      stage4TimerLastText = '';
      return;
    }
    showStage4Timer(true);
    let txt = '';
    if(stage4IsFrozen()){
      const left = Math.max(0, stage4FreezeLeftSec || 0);
      txt = `凍結中 ${Math.ceil(left)}秒`;
    }else{
      const left = Math.max(0, stage4CycleLeftSec || 0);
      txt = `切替まで ${Math.ceil(left)}秒`;
    }
    if(txt !== stage4TimerLastText){
      stage4TimerLastText = txt;
      stage4Timer.textContent = txt;
    }
  }


  // ---- Normal Stage 5: permafrost mechanic (phase-based) ----
function isNormalStage5(){
  return currentMode === "normal" && stageIndex === 4;
}

function stage5HighlightFrequency(){
  if(!isNormalStage5()) return 0;
  // Phase 1–2: every 3 words, Phase 3: every 2 words
  return (stage5Phase >= 3) ? 2 : 3;
}
function stage5FrostWindowSec(){
  if(!isNormalStage5()) return 0;
  // Phase 1: 5s, Phase 2–3: 4s
  return (stage5Phase >= 2) ? 4 : 5;
}

function stage5BossVariantForPhase(phase){
  // Normal Stage 5: Phase 1 uses bossFile, Phase 2 uses bossFile2, Phase 3 uses bossFile3.
  if(phase === 2) return 2;
  if(phase === 3) return 3;
  return 1;
}


function stage5ArmFrost(w, elapsed){
  if(!isNormalStage5() || gameState !== "playing") return;
  if(!w || w.state !== "landed") return;
  if(!w.s5Highlighted || w.s5Permafrost) return;
  if(w.s5FrostArmed) return;

  w.s5FrostArmed = true;
  w.s5FrostDeadlineSec = (Number.isFinite(elapsed) ? elapsed : stageElapsedSec()) + stage5FrostWindowSec();
  w.s5FrostLastShown = null;
}

function stage5MakePermafrost(w){
  if(!w || w.s5Permafrost) return;

  // Remember what this used to be, so typing the old answer can be safely ignored.
  w.s5FrozenFromNorm = (w.answerNorm || normalizeAnswer(w.answer) || "");

  w.s5Permafrost = true;
  w.s5FrostArmed = false;
  w.s5Highlighted = false;

  // "Frozen": remove its Japanese/English content and make it non-interactable.
  w.prompt = "";
  w.answer = "";
  w.answerNorm = "";

  try{
    if(w.promptEl) w.promptEl.textContent = "❄";
    if(w.answerEl) w.answerEl.textContent = "";
  }catch(_){}

  try{
    if(w.el){
      w.el.classList.remove("s5Target");
      w.el.classList.add("permafrost");
    }
  }catch(_){}

  try{
    if(w.tagEl) w.tagEl.textContent = "";
  }catch(_){}
}

function stage5UpdateFrost(){
  if(!isNormalStage5() || gameState !== "playing") return;
  const elapsed = stageElapsedSec();

  for(const w of wordsOnField){
    if(!w || w.state !== "landed") continue;
    if(w.s5Permafrost) continue;
    if(!w.s5FrostArmed) continue;

    const rem = Math.max(0, Math.ceil((w.s5FrostDeadlineSec || 0) - elapsed));
    if(w.tagEl && rem !== w.s5FrostLastShown){
      w.s5FrostLastShown = rem;
      w.tagEl.textContent = `ICE ${rem}`;
    }

    if(elapsed >= (w.s5FrostDeadlineSec || 0)){
      stage5MakePermafrost(w);
    }
  }
}

function stage5ClearNonPermafrostWords(){
  if(!isNormalStage5()) return;

  const ids = [];
  for(const w of wordsOnField){
    if(!w) continue;
    if(w.s5Permafrost) continue;
    ids.push(w.id);
  }
  for(const id of ids) removeWord(id);
  if(ids.length) restackLanded();
}

function stage5IsFrozenInput(norm){
  if(!isNormalStage5() || !norm) return false;
  for(const w of wordsOnField){
    if(!w || !w.s5Permafrost) continue;
    if(w.s5FrozenFromNorm && w.s5FrozenFromNorm === norm) return true;
  }
  return false;
}

function ex1IsFrozenInput(norm){
  if(!isExtraStage1() || !norm) return false;
  for(const w of wordsOnField){
    if(!w || !w.s5Permafrost) continue;
    if(w.s5FrozenFromNorm && w.s5FrozenFromNorm === norm) return true;
  }
  return false;
}


  // ---- Extra Stage 1 mechanic: Phase 1 permafrost + Phase 2 revive/ghost/var-speed ----
  function isExtraStage1(){
    return currentMode === "extra" && stageIndex === 0;
  }
  function ex1HighlightFrequency(){
    // Permafrost targets: every 2 words in both Phase 1 and Phase 2
    return isExtraStage1() ? 2 : 0;
  }
  function ex1RandomFallMult(){
    // Variable fall rates in Phase 2
    return 0.45 + Math.random() * 1.40; // 0.45 .. 1.85 (more noticeable)
  }
  function ex1ArmPermafrost(wordObj){
    if(!wordObj) return;
    if(wordObj.s5Permafrost) return;
    if(wordObj.ex1DeadlineMs) return; // already armed
    wordObj.ex1DeadlineMs = nowMs() + 4000;
    try{ wordObj.el && wordObj.el.classList.add("flash"); }catch(_){}
    if(wordObj.tagEl) wordObj.tagEl.textContent = "4";
  }
  function ex1UpdatePermafrost(){
    if(!isExtraStage1()) return;
    const t = nowMs();
    for(const w of wordsOnField){
      if(!w || w.state !== "landed") continue;
      if(!w.ex1Highlighted) continue;
      if(w.s5Permafrost) continue;
      if(!w.ex1DeadlineMs) continue;

      const remMs = w.ex1DeadlineMs - t;
      if(remMs <= 0){
        w.ex1Permafrost = true;
        stage5MakePermafrost(w);
        try{ w.el && w.el.classList.remove("ex1Target"); }catch(_){}
        try{ w.el && w.el.classList.remove("flash"); }catch(_){}
      }else{
        const rem = Math.max(1, Math.ceil(remMs / 1000));
        if(w.tagEl && w.tagEl.textContent !== String(rem)) w.tagEl.textContent = String(rem);
      }
    }
  }
  function ex1EnterPhase2(){
    if(!isExtraStage1()) return;
    ex1Phase = 2;

    // Clear all non-permafrost words
    resetField({ preservePermafrost: true });

    // Boss revives
    bossMaxHp = 29;
    bossHp = 29;
    bossVariantPhase = 2;
    // async swap; no need to await
    try{ setBossVariant(STAGES[stageIndex], 2); }catch(_){}

    // Reset spawn accumulator so Phase 2 feels clean
    spawnAccMs = 0;
    spawnCountThisStage = 0; // restart cadence for Phase 2 mechanics

    pushMsg("❄ PHASE 2 — REVIVE!", true);
    updateUI();
  }





  // ---- Extra Stage 2 mechanic: timer + highlight + scramble ----
  function isExtraStage2(){
    return currentMode === "extra" && stageIndex === 1;
  }
  function ex2HighlightFrequency(){
    if(!isExtraStage2()) return 0;
    // Phase mechanics removed for Extra Stage 2: keep a constant difficulty
    return 3;
  }
  function ex2CycleSeconds(){
    if(!isExtraStage2()) return 0;
    // Phase mechanics removed for Extra Stage 2: keep a constant shuffle timer
    return 5;
  }

function ex2RandRange(a, b){
  return a + (b - a) * Math.random();
}
function ex2RandomFallMult(){
  // Noticeable variation but still readable/playable.
  return (Math.random() < 0.5) ? ex2RandRange(0.60, 0.95) : ex2RandRange(1.15, 1.70);
}
function ex2ApplyPhase4ToExistingWords(){
  // Phase 4: all words ignore collision while falling, and fall at different rates.
  for(const w of wordsOnField){
    if(!w) continue;
    w.ignoreCollision = true;
    if(w.state === "falling"){
      w.ex2FallMult = ex2RandomFallMult();
    }
  }
}
  function ex2BossVariantForPhase(p){
    // EX2 boss art is phase-locked (no HP-based swapping):
    // Phase 1-2 => v1, Phase 3-4 => v2, Phase 6 => v3.
    // Phase 5 is the trap transition (boss not visible), so we just keep v2.
    if(p >= 6) return 3;
    if(p >= 3) return 2;
    return 1;
  }




  function ex2HandlePhaseTriggers(elapsedSec){
  if(!isExtraStage2()) return;
  // Phase 6 is manually-entered and must not be overwritten by the time-based phase logic.
  if(ex2Phase >= 6) return;

  // Time-based phases:
  // Phase 1: 0–40s    (obscure every 3 spawns)
  // Phase 2: 40–68s   (obscure every 2 spawns)
  // Phase 3: 68–98s   (Phase 2 spawn cadence carries over; on LAND: toggle reveal/obscure)
  // Phase 4: 98–130s  (Phase 2+3 carry over; ALL words ignore collision while falling + per-word fall speed variance)
  // Phase 5: 130s+    (defaults to Phase 4 behavior until overridden)
  let target = 1;
  if(elapsedSec >= EX2_PHASE1_END_SEC) target = 2;
  if(elapsedSec >= EX2_PHASE2_END_SEC) target = 3;
  if(elapsedSec >= EX2_PHASE3_END_SEC) target = 4;
  if(elapsedSec >= EX2_PHASE4_END_SEC) target = 5;

  if(target !== ex2Phase){
    ex2Phase = target;
    ex2PhaseSpawnCount = 0; // restart per-phase cadence
    // Phase-locked EX2 boss sprite
    const desiredV = ex2BossVariantForPhase(ex2Phase);
    if(desiredV !== bossVariantPhase){
      bossVariantPhase = desiredV;
      try{ setBossVariant(STAGES[stageIndex], desiredV); }catch(_){/* ignore */}
    }

    if(ex2Phase === 2 && !ex2Phase2Announced){
      ex2Phase2Announced = true;
      try{ pushMsg("EX2: フェーズ2", true); }catch(_){}
    }
    if(ex2Phase === 3 && !ex2Phase3Announced){
      ex2Phase3Announced = true;
      try{ pushMsg("EX2: フェーズ3", true); }catch(_){}
    }
    if(ex2Phase === 4 && !ex2Phase4Announced){
      ex2Phase4Announced = true;
      try{ pushMsg("EX2: フェーズ4", true); }catch(_){}
      ex2ApplyPhase4ToExistingWords();
    }
    if(ex2Phase === 5 && !ex2Phase5Announced){
      ex2Phase5Announced = true;
      try{ pushMsg("EX2: フェーズ5", true); }catch(_){}

      // Phase 5:
      // - Clear all words / stop EX2 clear-on-BGM-end
      // - Stop the song
      // - Kick the player into a fake Normal Stage 1 (dream-like), with a hidden 10s timer.
      // Save the "real" EX2 run state so Phase 6 can resume the song/timer later.
      try{
        const now = nowMs();
        ex2ResumeSnapshot = {
          elapsedSec: elapsedSec,
          playerHp, playerMaxHp, continuesLeft, mistakes,
          bossHp, bossMaxHp, bossVariantPhase,
          spawnCountThisStage,
          ex2PhaseSpawnCount,
          ex2CycleSec,
          ex2ShuffleRemainingMs: (ex2NextShuffleAtMs ? Math.max(0, ex2NextShuffleAtMs - now) : 0),
          bgm: {
            src: currentBgm || (bgm.currentSrc || ""),
            time: (Number.isFinite(bgm.currentTime) ? bgm.currentTime : 0),
            loop: !!bgm.loop
          }
        };
      }catch(_){
        ex2ResumeSnapshot = null;
      }
      try{ saveEx2ResumeSnapshot(ex2ResumeSnapshot); }catch(_){/* ignore */}

      ex2ClearOnBgmEndActive = false;
      ex2ClearOnBgmEndSrc = "";
      try{ stopBgm(); }catch(_){}
      resetField();

      ex2EnterFakeStage1({fromEx2:true});
    }
  }
}



  // Extra Stage 2 Phase 3+: toggle English obscuring once the word lands.
  // - If it was obscured while falling, reveal it on land.
  // - If it was visible while falling, obscure it on land.
  function ex2ToggleObscureOnLand(w){
    if(!w || w.ex2LandToggled) return;
    w.ex2LandToggled = true;

    w.hidePromptWhileFalling = !w.hidePromptWhileFalling;

    const aEl = w.answerEl || (w.el ? w.el.querySelector(".answer") : null);
    if(aEl){
      aEl.textContent = w.hidePromptWhileFalling ? makeUnreadableAnswer(w.answer) : w.answer;
      try{ aEl.setAttribute("title", aEl.textContent || ""); }catch(_){/* ignore */}
      try{ fitAnswerToRight(w.el || (aEl.closest ? aEl.closest(".word") : null)); }catch(_){/* ignore */}
    }
  }

  // ---- Extra Stage 3 mechanic: variable fall speed + ignore collision while falling ----
  function isExtraStage3(){
    return EXTRA_SPECIAL_MECHANICS_ENABLED && currentMode === "extra" && stageIndex === 2;
  }
  function ex3SpecialFrequency(){
    if(!isExtraStage3()) return 0;
    // "boss hp drops below half" => strictly below half
    return (bossHp < (bossMaxHp / 2)) ? 1 : 2;
  }
  function ex3RandRange(a, b){
    return a + (b - a) * Math.random();
  }
  function ex3RandomFallMult(){
    // Either noticeably slower or faster.
    return (Math.random() < 0.5) ? ex3RandRange(0.55, 0.85) : ex3RandRange(1.25, 1.75);
  }


  let ex2Active = false;
  let ex2NextShuffleAtMs = 0;
  let ex2CycleSec = 0;

  // Extra Stage 2 phases (time-based)
  let ex2Phase = 0; // 1..5 (0 = inactive)
  let ex2Phase2Announced = false;
  let ex2Phase3Announced = false;
  let ex2Phase4Announced = false;
  let ex2Phase5Announced = false;
  let ex2PhaseSpawnCount = 0; // counts falling spawns within the current phase

  // ---- EX2 Phase 5 trap: dream-like fake Normal Stage 1 (redo) ----
  // Phase 5 behavior:
  // - Stop EX2 survival-clear tracking, stop the EX2 song, clear all words.
  // - Kick the player into a fake Normal Stage 1.
  //   * Spawn rate starts at 50% of Normal Stage 1 (interval ×2).
  //   * When 8 words are successfully cleared, spawn rate hard-switches to 5x Normal (interval ×0.2),
  //     and fall speed hard-switches to 5x Normal. (No incremental ramp after that.)
  //   * BGM plays backwards (expects a "_reverse" BGM file next to index.html).
  // - After 10 successful clears, immediately stack 5 "wake up" words and stop spawns.
  // - Clearing all 5 "wake up" words proceeds to Phase 6 (resume EX2).

  let ex2FakeTrapActive = false;      // runtime: we are inside the Phase 5 trap experience
  let ex2FakeCorrectCount = 0;        // successful clears inside the fake stage (0..10)
  let ex2WakeUpActive = false;        // "wake up" stack is active (5 words)
  let ex2WakeRemaining = 0;           // remaining "wake up" words

  // Saved state from the real EX2 run (captured when Phase 5 begins), used to resume on Phase 6.
  let ex2ResumeSnapshot = null;
  let ex2Phase6SpawnTimer = null;

  function isEx2TrapPhase5(){ return (ex2TrapPhase === "5"); }
  function isEx2TrapActive(){ return !!ex2TrapPhase; }

  function setDreamLike(on){
    try{ document.body.classList.toggle("dreamlike", !!on); }catch(_){}
  }

  let negativeModeOn = false;
  function setNegativeMode(on){
    on = !!on;
    if(negativeModeOn === on) return;
    negativeModeOn = on;
    try{
      document.body.classList.toggle("negativeModeAll", on);
    }catch(_){/* ignore */}
  }

function ex2ReverseBgmSrc(src){
    if(!src) return "";
    if(/_reverse\.[a-z0-9]+$/i.test(src)) return src;
    const m = String(src).match(/^(.*)(\.[a-z0-9]+)$/i);
    if(m) return `${m[1]}_reverse${m[2]}`;
    return `${src}_reverse`;
  }

  function ex2TrapSpawnMultiplier(){
    const n = clamp((ex2FakeCorrectCount|0), 0, 10);
    // Phase 5 trap pacing:
    // - 0..7 clears => ×2.0 interval (50% spawn rate)
    // - 8+ clears  => ×0.2 interval (5x spawn rate)
    // (No incremental ramp—hard switch at 8 clears.)
    return (n >= 8) ? 0.2 : 2;
  }

  function ex2EnterFakeStage1(opts = {}){
    // Phase 5: fake instance of Normal Stage 1 (dream-like).
    ex2TrapPhase = "5";
    saveEx2TrapPhase("5");

    ex2FakeTrapActive = true;
    ex2FakeCorrectCount = 0;
    ex2WakeUpActive = false;
    ex2WakeRemaining = 0;

    setDreamLike(true);
    setNegativeMode(false);

    // Hard-cancel any UI flow and force gameplay state
    try{ cancelUiFlow(); }catch(_){/* ignore */}
    cleanupContinueListeners();

    // Switch to Normal rules for Stage 1 mechanics
    try{ setMode("normal"); }catch(_){/* ignore */}
    stageIndex = 0;

    // Reset the field and core per-stage counters (do NOT wipe run scoring)
    resetField();
    hideBossBubble();
    showStage5Timer(false);
    showEx2Timer(false);
    showEx4Timer(false);

    spawnAccMs = 0;
    spawnCountThisStage = 0;
    midFightBubbleShown = false;

    // Stage clock baseline (trap time does not count toward EX2)
    stagePausedTotalMs = 0;
    stagePauseStartMs = null;
    stagePlayStartMs = nowMs();

    // Player baseline
    playerMaxHp = BASE_PLAYER_MAX_HP;
    playerHp = playerMaxHp;
    continuesLeft = 0; // no continue prompt; death loops instantly

    // Boss baseline (boss HP should never end the trap, so we prevent boss damage elsewhere)
    const stage = STAGES[0];
    bossMaxHp = stage?.bossMaxHp || 1;
    bossHp = bossMaxHp;
    bossVariantPhase = 1;
    baseHitDamage = stage?.hitDamage || 1;

    // Start the fake Normal Stage 1 immediately (no dialogue/countdown).
    autoSpawnEnabled = true;
    gameState = "playing";
    setInputsEnabled(true);
    showOverlay(false);

    // Apply art and start reversed BGM
    try{ setStageArt(stage); }catch(_){/* ignore */}
    try{
      const rev = ex2ReverseBgmSrc(stage?.playBgmFile || "");
      if(rev){
        setBgm(rev, true);
      }else{
        stopBgm();
      }
    }catch(_){
      try{ stopBgm(); }catch(__){}
    }

    try{ pushMsg("…", true); }catch(_){/* ignore */}
    updateUI();
  }

  function ex2BeginWakeUpStack(){
    if(!isEx2TrapPhase5()) return;
    if(ex2WakeUpActive) return;

    ex2WakeUpActive = true;
    ex2WakeRemaining = 5;

    // Stop further spawns and present the wake-up stack immediately
    autoSpawnEnabled = false;
    spawnAccMs = 0;

    resetField();

    for(let i=0;i<5;i++){
      const w = spawnOneWord({prompt:"wake up", answer:"wake up", state:"landed", countSpawn:false});
      if(!w) continue;
      w.ex2WakeUp = true;
      w.s1TwoHit = false;
      w.s1HitCount = 0;
      try{ w.el && w.el.classList.remove("s1Target"); }catch(_){/* ignore */}
      w.ignoreCollision = true;
      w.fallMult = 1;
      w.fallSpeedOverride = null;
      try{ w.el && w.el.classList.add("wakeUpWord"); }catch(_){/* ignore */}
    }
    restackLanded();
    try{ pushMsg("WAKE UP", true); }catch(_){/* ignore */}
    updateUI();
  }

  function ex2OnTrapWordCleared(){
    if(!isEx2TrapPhase5()) return;
    if(ex2WakeUpActive) return;
    ex2FakeCorrectCount = clamp((ex2FakeCorrectCount|0) + 1, 0, 10);
    if(ex2FakeCorrectCount >= 10){
      ex2BeginWakeUpStack();
    }
  }

  function ex2OnWakeUpCleared(){
    if(!ex2WakeUpActive) return;
    ex2WakeRemaining = Math.max(0, (ex2WakeRemaining|0) - 1);
    if(ex2WakeRemaining <= 0){
      ex2WakeUpActive = false;
      autoSpawnEnabled = false;
      resetField();
      ex2EnterPhase6Hold();
    }
  }

  function ex2EnterPhase6Hold(){
    // Phase 6 (real): return to Extra Stage 2, resume the EX2 song/timer, spawn 6 words,
    // and delay further spawns for 20 seconds. Only Phase 4 mechanics carry over:
    // - All words ignore collision while falling
    // - All words fall at different rates
    // Additionally: ALL English translations are obscured (always).

    // Exit trap + clear persistence
    ex2TrapPhase = "";
    saveEx2TrapPhase("");
    ex2FakeTrapActive = false;
    ex2FakeCorrectCount = 0;
    ex2WakeUpActive = false;
    ex2WakeRemaining = 0;

    setDreamLike(false);
    setNegativeMode(false);

    // Switch back to Extra mode / EX Stage 2
    try{ setMode("extra"); }catch(_){}
    stageIndex = 1; // EX Stage 2
    const stage = STAGES[stageIndex];

    // Restore core play state
    gameState = "playing";
    setInputsEnabled(true);
    showOverlay(false);

    // Resume EX2 timer (do NOT include time spent in the fake instance)
    const snap = ex2ResumeSnapshot || loadEx2ResumeSnapshot();
    ex2ResumeSnapshot = snap;
    try{ saveEx2ResumeSnapshot(null); }catch(_){/* ignore */}
    const resumeElapsed = (snap && Number.isFinite(snap.elapsedSec)) ? snap.elapsedSec : EX2_PHASE4_END_SEC;
    stagePausedTotalMs = 0;
    stagePauseStartMs = null;
    stagePlayStartMs = nowMs() - (resumeElapsed * 1000);

    // Restore HP/score-ish bits (best effort)
    if(snap){
      try{
        playerMaxHp = snap.playerMaxHp || BASE_PLAYER_MAX_HP;
        playerHp = clamp(snap.playerHp ?? playerMaxHp, 0, playerMaxHp);
        continuesLeft = (snap.continuesLeft ?? continuesLeft);
        mistakes = (snap.mistakes ?? mistakes);
        bossMaxHp = (snap.bossMaxHp ?? stage.bossMaxHp);
        bossHp = (snap.bossHp ?? bossMaxHp);
        bossVariantPhase = (snap.bossVariantPhase ?? 1);
      }catch(_){/* ignore */}
    }else{
      playerMaxHp = BASE_PLAYER_MAX_HP;
      playerHp = playerMaxHp;
      bossMaxHp = stage.bossMaxHp || 1;
      bossHp = bossMaxHp;
      bossVariantPhase = 1;
    }

    // Ensure EX2 survival clear is active again
    ex2ClearOnBgmEndActive = true;
    ex2ClearOnBgmEndSrc = stage.playBgmFile || "";

    // Set art back to EX2
    try{ setStageArt(stage); }catch(_){/* ignore */}

    // Set Phase 6
    ex2Phase = 6;

    // Phase-locked EX2 boss sprite: Phase 6 => v3
    bossVariantPhase = 3;
    try{ setBossVariant(stage, 3); }catch(_){/* ignore */}
    ex2PhaseSpawnCount = 0;

    // Clear any existing words and spawn exactly 6 immediately
    resetField();
    spawnAccMs = 0;
    spawnCountThisStage = 0;

    for(let i=0;i<6;i++){
      spawnOneWord({state:"falling", countSpawn:true});
    }

    // Resume BGM from the saved point (best-effort)
    if(snap && snap.bgm && snap.bgm.src){
      try{
        setBgm(snap.bgm.src, snap.bgm.loop, false);
        try{ bgm.currentTime = Math.max(0, snap.bgm.time || 0); }catch(_){}
        tryPlayBgm();
      }catch(_){
        // fallback
        try{ setBgm(stage.playBgmFile, stage.playBgmLoop !== false); }catch(__){}
      }
    }else{
      try{ setBgm(stage.playBgmFile, stage.playBgmLoop !== false); }catch(_){}
    }

    // Resume EX2 shuffle timer near where it left off (best-effort)
    try{
      startEx2Mechanic();
      if(snap && Number.isFinite(snap.ex2ShuffleRemainingMs)){
        ex2CycleSec = (snap.ex2CycleSec || ex2CycleSec || 5);
        ex2NextShuffleAtMs = nowMs() + Math.max(0, snap.ex2ShuffleRemainingMs);
      }
      updateEx2Mechanic();
    }catch(_){/* ignore */}

    // Phase 6: delay all further spawns for 20 seconds (but keep the 6 pre-spawned words)
    autoSpawnEnabled = false;
    if(ex2Phase6SpawnTimer){ clearTimeout(ex2Phase6SpawnTimer); ex2Phase6SpawnTimer = null; }
    ex2Phase6SpawnTimer = setTimeout(() => {
      if(gameState === "playing" && isExtraStage2() && ex2Phase === 6){
        autoSpawnEnabled = true;
      }
    }, 20000);

    try{ pushMsg("EX2: フェーズ6", true); }catch(_){/* ignore */}
    updateUI();
  }

  function ex2ResetTrapInstance(){
    // Reset behavior inside the trap: restart the fake instance from scratch.
    ex2EnterFakeStage1({fromReset:true});
  }

  function updateEx2TrapRuntime(){
    if(!isEx2TrapPhase5()) return;
    if(gameState !== "playing") return;

    // Ensure dream state stays on while trapped
    if(!document.body.classList.contains("dreamlike")) setDreamLike(true);
  }


  // Extra Stage 2: clear condition (survival) — clear ONLY when the stage BGM ends
  let ex2ClearOnBgmEndActive = false;
  let ex2ClearOnBgmEndSrc = "";

  const EX2_PHASE1_END_SEC = 40;  // Phase 1: 0–40s
  const EX2_PHASE2_END_SEC = 68;  // Phase 2: 40–68s (Phase 3 starts at 68s)
  const EX2_PHASE3_END_SEC = 98;  // Phase 3: 68–98s (Phase 4 starts at 98s)
  const EX2_PHASE4_END_SEC = 130; // Phase 4: 98–130s (Phase 5 starts at 130s)



  function showEx2Timer(show){
    if(!ex2Timer) return;
    ex2Timer.classList.toggle("show", !!show);
  }

  function showEx2EndTimer(show){
    if(!ex2EndTimer) return;
    ex2EndTimer.classList.toggle("show", !!show);
  }

  function stopEx2Mechanic(){
    ex2Active = false;
    ex2NextShuffleAtMs = 0;
    ex2CycleSec = 0;
    showEx2Timer(false);
  }

  function startEx2Mechanic(){
    if(!(gameState === "playing" && isExtraStage2())){
      stopEx2Mechanic();
      return;
    }
    ex2Active = true;
    ex2CycleSec = ex2CycleSeconds() || 5;
    ex2NextShuffleAtMs = nowMs() + ex2CycleSec * 1000;
    showEx2Timer(true);
    updateEx2Mechanic();
  }

  function pickRandomDifferent(stage, curPrompt, curAnswer){
    const arr = stage?.words || [];
    if(arr.length === 0) return { prompt: curPrompt, answer: curAnswer };

    let choice = null;
    for(let i=0;i<12;i++){
      const w = arr[Math.floor(Math.random() * arr.length)];
      if((w.prompt !== curPrompt) || (w.answer !== curAnswer)){
        choice = w;
        break;
      }
    }
    if(!choice) choice = arr[Math.floor(Math.random() * arr.length)];
    return { prompt: choice.prompt, answer: choice.answer };
  }

  function ex2ShuffleHighlightedWords(){
    if(!isExtraStage2()) return;
    const stage = STAGES[stageIndex];
    const targets = wordsOnField.filter(w => w && w.ex2Highlighted);
    if(targets.length === 0) return;

    for(const w of targets){
      const nw = pickRandomDifferent(stage, w.prompt, w.answer);
      w.prompt = nw.prompt;
      w.answer = nw.answer;
      w.answerNorm = normalizeAnswer(w.answer);

      if(w.promptEl){
        w.promptEl.textContent = w.prompt;
      }
      const aEl = w.answerEl || (w.el ? w.el.querySelector(".answer") : null);
      if(aEl){
        aEl.textContent = w.hidePromptWhileFalling ? makeUnreadableAnswer(w.answer) : w.answer;
      }
    }
  }

    let ex2TimerLastText = "";
    let ex2EndTimerLastText = "";

  function updateEx2Mechanic(){
    if(!(gameState === "playing" && isExtraStage2() && ex2Active)){
      showEx2Timer(false);
      showEx2EndTimer(false);
      return;
    }

    // Ensure the timers are visible again after pauses/continues
    showEx2Timer(true);

    // EX2 stage-end countdown (clears when the EX2 BGM ends)
    if(ex2ClearOnBgmEndActive && !ex2FakeTrapActive){
      showEx2EndTimer(true);
      let txt = "残り --:--";
      if(Number.isFinite(bgm.duration) && bgm.duration > 0){
        const ct = (Number.isFinite(bgm.currentTime) ? bgm.currentTime : 0);
        const remain = Math.max(0, bgm.duration - ct);
        txt = `残り ${formatTime(remain)}`;
      }
      if(ex2EndTimer && txt !== ex2EndTimerLastText){
        ex2EndTimerLastText = txt;
        ex2EndTimer.textContent = txt;
      }
    }else{
      showEx2EndTimer(false);
      ex2EndTimerLastText = "";
    }

    const now = nowMs();
    const desired = ex2CycleSeconds() || 5;

    // If we switched into the "below half HP" mode mid-cycle, shorten the remaining time if needed
    if(desired !== ex2CycleSec){
      const remaining = (ex2NextShuffleAtMs - now) / 1000;
      if(remaining > desired){
        ex2NextShuffleAtMs = now + desired * 1000;
      }
      ex2CycleSec = desired;
    }

    const left = Math.max(0, (ex2NextShuffleAtMs - now) / 1000);
    if(ex2Timer){
      const txt = `変化まで ${Math.ceil(left)}秒`;
      if(txt !== ex2TimerLastText){
        ex2TimerLastText = txt;
        ex2Timer.textContent = txt;
      }
    }

    if(now >= ex2NextShuffleAtMs){
      ex2ShuffleHighlightedWords();
      ex2CycleSec = ex2CycleSeconds() || desired || 5;
      ex2NextShuffleAtMs = nowMs() + ex2CycleSec * 1000;
    }
  }

  // ---- Extra Stage 4 mechanic: survive phases until BGM ends ----
  function isExtraStage4(){
    return EXTRA_SPECIAL_MECHANICS_ENABLED && currentMode === "extra" && stageIndex === 3;
  }

  let ex4Phase = 0; // 1..5
  let ex4SpawnEnabled = false;

  // Shuffle queue: every 2 doubles/triples, shuffle those words after 5 seconds
  let ex4BatchIds = [];
  let ex4ShuffleQueue = []; // {atMs:number, ids:number[]}

  // EX4 constants (seconds from stage start)
  const EX4_T_PHASE2 = 25;
  const EX4_T_PHASE3 = 71;
  const EX4_T_PHASE4 = 134;
  const EX4_T_PHASE5 = 157;

  let nextGroupId = 1;

  function showEx4Timer(show){
    if(!ex4Timer) return;
    ex4Timer.classList.toggle("show", !!show);
  }

  function ex4GroupSize(){
    if(!isExtraStage4()) return 1;
    if(ex4Phase === 2 || ex4Phase === 3) return 2;
    if(ex4Phase === 5) return 3;
    return 1;
  }

  function ex4ClearShuffleState(){
    ex4BatchIds = [];
    ex4ShuffleQueue = [];
  }

  function ex4QueueShuffleIfReady(){
    const need = (ex4Phase === 3) ? 4 : (ex4Phase === 5 ? 6 : 0);
    if(!need) return;

    while(ex4BatchIds.length >= need){
      const ids = ex4BatchIds.splice(0, need);
      ex4ShuffleQueue.push({ atMs: nowMs() + 5000, ids });
    }
  }

  function ex4DoShuffle(ids){
    for(const id of ids){
      const w = wordsOnField.find(x => x.id === id);
      if(!w) continue;
      // pick a different word if possible
      const before = `${w.prompt}||${w.answer}`;
      let picked = null;
      for(let tries=0; tries<8; tries++){
        const cand = pickStageWord();
        if(!cand) continue;
        const after = `${cand.prompt}||${cand.answer}`;
        if(after !== before){
          picked = cand;
          break;
        }
      }
      if(!picked) picked = pickStageWord();
      if(!picked) continue;

      w.prompt = picked.prompt;
      w.answer = picked.answer;
      w.answerNorm = normalizeAnswer(w.answer);

      const pEl = w.promptEl || w.el.querySelector(".prompt");
      if(pEl) pEl.textContent = w.prompt;

      // IMPORTANT: update the visible English too, otherwise players will type what they see
      // and the internal answer may have already changed (EX4 shuffle phases).
      const aEl = w.answerEl || w.el.querySelector(".answer");
      if(aEl){
        aEl.textContent = w.hidePromptWhileFalling ? makeUnreadableAnswer(w.answer) : w.answer;
      }
    }
  }

  function ex4UpdateShuffleQueue(){
    if(!isExtraStage4()) return;
    if(!(gameState === "playing")) return;
    const now = nowMs();
    for(let i=ex4ShuffleQueue.length - 1; i>=0; i--){
      const ev = ex4ShuffleQueue[i];
      if(now >= ev.atMs){
        ex4DoShuffle(ev.ids);
        ex4ShuffleQueue.splice(i, 1);
      }
    }
  }

    let ex4TimerLastText = "";

  function updateEx4Timer(){
    if(!(gameState === "playing" && isExtraStage4())){
      showEx4Timer(false);
      return;
    }
    showEx4Timer(true);

    let txt = "残り --:--";
    if(Number.isFinite(bgm.duration) && bgm.duration > 0){
      const ct = (Number.isFinite(bgm.currentTime) ? bgm.currentTime : 0);
      const remain = Math.max(0, bgm.duration - ct);
      txt = `残り ${formatTime(remain)}`;
    }
    if(txt !== ex4TimerLastText){
      ex4TimerLastText = txt;
      ex4Timer.textContent = txt;
    }
  }

    function ex4Prestack(n){
      const h = laneHeight();
  
      // Extra Stage 4 Phase 1: randomly obscure 3 of the pre-stacked English answers
      const obscureCount = (isExtraStage4() && ex4Phase === 1) ? Math.min(3, n) : 0;
      const obscureSet = new Set();
      while(obscureSet.size < obscureCount){
        obscureSet.add(Math.floor(Math.random() * n));
      }
  
      for(let i=0;i<n;i++){
        const cand = pickStageWord();
        if(!cand) continue;
  
        const shouldObscure = obscureSet.has(i);
        const shownAnswer = shouldObscure ? makeUnreadableAnswer(cand.answer) : cand.answer;
  
        const el = document.createElement("div");
        el.className = "word landed" + (shouldObscure ? " obscured" : "");
        el.innerHTML = `<div class="prompt" title="${escapeHtml(cand.prompt)}">${escapeHtml(cand.prompt)}</div>
          <div class="right">
            <span class="tag"></span>
            <span class="answer muted" title="${escapeHtml(shownAnswer)}">${escapeHtml(shownAnswer)}</span>
          </div>`;
        wordLane.appendChild(el);
  
        const y = h - 30 * (i + 1);
        const obj = {
          id: nextWordId++,
          prompt: cand.prompt,
          answer: cand.answer,
          answerNorm: normalizeAnswer(cand.answer),
          y,
          state: "landed",
          el,
          promptEl: el.querySelector(".prompt"),
          answerEl: el.querySelector(".answer"),
          tagEl: el.querySelector(".tag"),
          hidePromptWhileFalling: shouldObscure, // keep obscured even while landed
          ex2Highlighted: false,
          fallMult: 1,
          ex3Ghost: false,
        };
        setWordY(el, y);
        wordsOnField.push(obj);
        fitAnswerToRight(el);
      }
      restackLanded();
    }

  function ex4ShowFakeDeath(show){
    if(!show){
      showOverlay(false);
      return;
    }
    // Fake death overlay that doesn't clear
    setOverlayText("GIVE UP", "", "");
    overlay.style.cursor = "default";
    showOverlay(true);
  }

  const ex4Laugh = new Audio();
  ex4Laugh.preload = "auto";

  // EX4 Phase 4: reset scare image overlay (sync to ex4 laugh BGM duration)
  let ex4ResetAnim = null;

  function ex4PrepareLaugh(){
    const stage = STAGES[stageIndex];
    const src = stage?.ex4LaughBgm || "";
    if(!src) return;
    if(ex4Laugh.src !== src){
      ex4Laugh.src = src;
    }
    try{ ex4Laugh.load(); }catch(_){}
  }

  function ex4WaitLaughDurationMs(timeoutMs = 300){
    return new Promise((resolve) => {
      const d0 = ex4Laugh.duration;
      if(Number.isFinite(d0) && d0 > 0){
        resolve(Math.round(d0 * 1000));
        return;
      }

      let done = false;
      const finish = (ms) => {
        if(done) return;
        done = true;
        ex4Laugh.removeEventListener("loadedmetadata", onMeta);
        ex4Laugh.removeEventListener("durationchange", onMeta);
        resolve(ms);
      };

      const onMeta = () => {
        const d = ex4Laugh.duration;
        finish((Number.isFinite(d) && d > 0) ? Math.round(d * 1000) : 2500);
      };

      ex4Laugh.addEventListener("loadedmetadata", onMeta, { once:true });
      ex4Laugh.addEventListener("durationchange", onMeta, { once:true });
      setTimeout(() => finish(2500), timeoutMs);
    });
  }

  function ex4StopResetScare(fast = false){
    if(!ex4ResetScare) return;

    if(ex4ResetAnim){
      try{ ex4ResetAnim.cancel(); }catch(_){}
      ex4ResetAnim = null;
    }

    if(fast){
      // Requirement: fade out immediately when entering phase 5
      ex4ResetScare.style.transition = "none";
      ex4ResetScare.style.opacity = "0";
      return;
    }

    ex4ResetScare.style.opacity = "0";
  }

  async function ex4PlayResetScare(){
    if(!ex4ResetScare) return;

    // Ensure metadata is available so the fade matches the laugh BGM duration
    ex4PrepareLaugh();
    playEx4Laugh();

    const durationMs = await ex4WaitLaughDurationMs(350);

    // Restart animation from 0 every time
    ex4StopResetScare(false);
    ex4ResetScare.style.transition = "none";
    ex4ResetScare.style.opacity = "0";
    void ex4ResetScare.offsetWidth;

    ex4ResetAnim = ex4ResetScare.animate(
      [{opacity:0},{opacity:0.8, offset:0.5},{opacity:0}],
      {duration: Math.max(300, durationMs), easing:"linear", fill:"forwards"}
    );
    ex4ResetAnim.onfinish = () => {
      ex4ResetAnim = null;
      ex4ResetScare.style.opacity = "0";
    };
  }

  function playEx4Laugh(){
    const stage = STAGES[stageIndex];
    const src = stage?.ex4LaughBgm || "";
    if(!src) return;
    if(isMuted) return;

    try{
      ex4Laugh.pause();
      ex4Laugh.currentTime = 0;
    }catch(_){}

    ex4Laugh.src = src;
    ex4Laugh.loop = false;
    ex4Laugh.volume = clamp(lastVol * 2.5, 0, 1); // 2.5x louder for EX4 laugh BGM

    ex4Laugh.play().catch(()=>{});
  }

  function ex4HandlePhaseEnter(newPhase){
    ex4Phase = newPhase;

    // EX4: swap boss art by phase group (1–2 / 3–4 / 5)
    const ex4Stage = STAGES[stageIndex];
    if(ex4Stage && isExtraStage4()){
      const desiredVariant = (ex4Phase === 5) ? 3 : (ex4Phase >= 3 ? 2 : 1);
      if(bossVariantPhase !== desiredVariant){
        bossVariantPhase = desiredVariant;
        // async swap; no need to await
        setBossVariant(ex4Stage, desiredVariant);
      }
    }

    // Always reset shuffle batch when switching phases
    ex4ClearShuffleState();

    if(ex4Phase === 1){
      // Phase 1: start with 5 words already stacked; no spawns
      ex4SpawnEnabled = false;
      showOverlay(false);
      setInputsEnabled(true);
      resetField({ preservePermafrost: (isNormalStage5() || isExtraStage1()) });
      ex4Prestack(5);
      spawnAccMs = 0;
      return;
    }

    if(ex4Phase === 2){
      ex4SpawnEnabled = true;
      showOverlay(false);
      setInputsEnabled(true);
      spawnAccMs = 0;
      return;
    }

    if(ex4Phase === 3){
      ex4SpawnEnabled = true;
      showOverlay(false);
      setInputsEnabled(true);
      spawnAccMs = 0;
      showBossBubble("I\'ll show you crazy!", 5000);
      return;
    }

    if(ex4Phase === 4){
      // Clear stack + stop spawns + fake death overlay
      ex4SpawnEnabled = false;
      resetField();
      spawnAccMs = 0;
      setInputsEnabled(false);
      ex4PrepareLaugh();
      ex4ShowFakeDeath(true);
      return;
    }

    if(ex4Phase === 5){
      // Resume play, remove fake death prompts
      ex4SpawnEnabled = true;
      // If the reset scare image is showing, fade it out immediately on Phase 5
      ex4StopResetScare(true);
      showOverlay(false);
      setInputsEnabled(true);
      spawnAccMs = 0;
      showBossBubble("Let\'s end this!", 5000);
      return;
    }
  }

  function ex4HandlePhaseTriggers(elapsedSec){
    if(!(gameState === "playing" && isExtraStage4())) return;

    let target = 1;
    if(elapsedSec >= EX4_T_PHASE5) target = 5;
    else if(elapsedSec >= EX4_T_PHASE4) target = 4;
    else if(elapsedSec >= EX4_T_PHASE3) target = 3;
    else if(elapsedSec >= EX4_T_PHASE2) target = 2;

    if(target !== ex4Phase){
      ex4HandlePhaseEnter(target);
    }
  }

  function ex4OnGroupSpawn(ids){
    if(!(isExtraStage4() && (ex4Phase === 3 || ex4Phase === 5))) return;
    ex4BatchIds.push(...ids);
    ex4QueueShuffleIfReady();
  }

  function updateEx4Mechanic(){
    updateEx4Timer();
    ex4UpdateShuffleQueue();

    // Keep EX4 overlay text correct if blocked reset got triggered
    if(gameState === "playing" && isExtraStage4() && ex4Phase === 4){
      // ensure overlay stays on
      showOverlay(true);
      overlayTitle.textContent = "GIVE UP";
    }
  }


  function spawnOneWord(opts = {}){
    if(gameState !== "playing") return null;

    const state = opts.state || "falling";

    const stagePick = (opts.prompt != null && opts.answer != null)
      ? {prompt: opts.prompt, answer: opts.answer}
      : pickStageWord();

    if(!stagePick) return null;
    const {prompt, answer} = stagePick;

    const countSpawn = (opts.countSpawn !== false);
    if(countSpawn && state === "falling") spawnCountThisStage++;

    // Normal Stage 1: every Nth word highlighted (4 -> 3 after boss HP drops below half). Highlighted words require two correct entries.
    const s1Freq = stage1HighlightFrequency();
    const s1Highlighted = (state === "falling" && s1Freq > 0 && (spawnCountThisStage % s1Freq === 0));

    // Extra Stage 1: Phase 1 permafrost targets (every 2 words)
    const ex1Freq = ex1HighlightFrequency();
    const ex1Highlighted = (state === "falling" && ex1Freq > 0 && (spawnCountThisStage % ex1Freq === 0));

    // Extra Stage 1: Phase 2 variable fall rates + ghosting
    const ex1VarSpeed = (isExtraStage1() && ex1Phase === 2 && state === "falling");
    const ex1FallMult = ex1VarSpeed ? ex1RandomFallMult() : 1;
    // Store a per-word absolute fall speed for EX1 Phase 2 so variance is guaranteed/visible.
    const ex1FallSpeedOverride = ex1VarSpeed ? (STAGES[stageIndex].fallSpeedPxPerSec * ex1FallMult) : null;
    // Phase 2: some words "ghost" (ignore collision while falling). Make it frequent enough to notice.
    const ex1Ghost = (isExtraStage1() && ex1Phase === 2 && state === "falling" &&
                     ((spawnCountThisStage % 3 === 0) || (Math.random() < 0.33)));

    // In Phase 2, ghost words should ALSO be permafrost targets.
    const ex1FrostTarget = (ex1Highlighted || (ex1Ghost && isExtraStage1() && ex1Phase === 2 && state === "falling"));

    // Extra Stage 2: time-based phases obscure the English every N spawns (per-phase cadence)
    let ex2ShouldObscure = false;
    if(isExtraStage2() && state === "falling" && countSpawn){
      const n = (ex2Phase === 1) ? 3 : (ex2Phase >= 2 ? 2 : 0);
      if(n > 0){
        ex2PhaseSpawnCount++;
        ex2ShouldObscure = (ex2PhaseSpawnCount % n === 0);
      }
    }

    let hidePromptWhileFalling = ex2ShouldObscure;
    // Phase 6: all English translations are obscured (always).
    if(isExtraStage2() && ex2Phase >= 6){
      hidePromptWhileFalling = true;
    }

    // Practice Mode: obscure the English translation on every 3rd spawned word (while falling).
    const practiceShouldObscure = (currentMode === "practice" && state === "falling" && countSpawn && (spawnCountThisStage % 3 === 0));
    const shouldObscureAnswer = hidePromptWhileFalling || practiceShouldObscure || challengeNoEnglish;

// Extra Stage 2 Phase 4+: all words ignore collision while falling and fall at different rates
const ex2Phase4Plus = (isExtraStage2() && ex2Phase >= 4 && state === "falling");
const ex2IgnoreCollision = ex2Phase4Plus;
const ex2FallMult = ex2Phase4Plus ? ex2RandomFallMult() : 1;

    // Extra Stage 2: every Nth word highlighted (phase mechanics removed: constant frequency)
    const ex2Freq = ex2HighlightFrequency();
    const ex2Highlighted = (state === "falling" && ex2Freq > 0 && (spawnCountThisStage % ex2Freq === 0));

    // Normal Stage 2: every Nth word highlighted (3 -> 2 after boss HP drops below half)
    const s2Freq = stage2HighlightFrequency();
    const s2Highlighted = (state === "falling" && s2Freq > 0 && (spawnCountThisStage % s2Freq === 0));

    // Normal Stage 5: every Nth word highlighted (Phase 1–2: 3, Phase 3: 2)
    const s5Freq = stage5HighlightFrequency();
    const s5Highlighted = (state === "falling" && s5Freq > 0 && (spawnCountThisStage % s5Freq === 0));
    // Normal Stage 3: forbidden words are re-selected every 4 seconds.
    // (See stage3UpdateCycle.)
    let s3Forbidden = false;

    // Normal Stage 3: after half HP, randomize fall speed per word (some slower/faster)
    const s3VarSpeed = (isNormalStage3() && (bossHp < (bossMaxHp / 2)));

    // Extra Stage 3: every Nth word gets a random fall speed and ignores collision while falling
    const ex3Freq = ex3SpecialFrequency();
    const ex3Special = (state === "falling" && ex3Freq > 0 && (spawnCountThisStage % ex3Freq === 0));
    const ex3FallMult = ex3Special ? ex3RandomFallMult() : 1;

    const el = document.createElement("div");
    el.className = "word"
            + (shouldObscureAnswer ? " obscured" : "")
      + ((ex1Ghost || ex3Special) ? " ghost" : "")
      + (s1Highlighted ? " s1Target" : "")
      + (ex1FrostTarget ? " ex1Target" : "")
      + (s2Highlighted ? " s2Target" : "")
      + (s5Highlighted ? " s5Target" : "")
      + (s3Forbidden ? " s3Forbidden" : "")
      + (ex2Highlighted ? " ex2Target" : "");

    const shownPrompt = prompt;
    const shownAnswer = shouldObscureAnswer ? makeUnreadableAnswer(answer) : answer;
    el.innerHTML = `<div class="prompt">${escapeHtml(shownPrompt)}</div>
      <div class="right">
        <span class="tag"></span>
        <span class="answer muted">${escapeHtml(shownAnswer)}</span>
      </div>`;
    wordLane.appendChild(el);

    const y = (opts.y != null) ? opts.y : -30;

    const obj = {
      id: nextWordId++,
      prompt,
      answer,
      answerNorm: normalizeAnswer(answer),
      y,
      state,
      el,
      promptEl: el.querySelector(".prompt"),
      answerEl: el.querySelector(".answer"),
      tagEl: el.querySelector(".tag"),
      hidePromptWhileFalling: shouldObscureAnswer,
      s1TwoHit: s1Highlighted,
      s1HitCount: 0,
      ex1Highlighted: ex1FrostTarget,
      ex1DeadlineMs: 0,
      ex1Permafrost: false,
      ex1Ghost,
      ex2Obscured: hidePromptWhileFalling,
      ex2Highlighted,
      s2Highlighted,
      s5Highlighted,
      s5FrostArmed: false,
      s5FrostDeadlineSec: 0,
      s5FrostLastShown: null,
      s5Permafrost: false,
      s2Flashing: false,
      s2FlashStartSec: 0,
      s2FlashSfx: null,
      ignoreCollision: ex2IgnoreCollision,
      ex2FallMult: ex2FallMult,
      fallMult: ex3FallMult * (s3VarSpeed ? stage3RandomFallMult() : 1) * ex1FallMult,
      fallSpeedOverride: ex1FallSpeedOverride,
      ex3Ghost: (ex3Special || ex1Ghost),
      s3Forbidden,
      groupId: opts.groupId || 0,
      groupIndex: opts.groupIndex || 0,
      spawnBaseCount: (Number.isFinite(opts.spawnBaseCount) ? opts.spawnBaseCount : undefined),
    };
if(state === "landed"){
      obj.hidePromptWhileFalling = (obj.hidePromptWhileFalling || (obj.ex2Obscured ? true : false));
      obj.ex3Ghost = false;
      obj.ex2Highlighted = false;
      obj.s2Highlighted = false;
      obj.s2Flashing = false;
      obj.s2FlashStartSec = 0;
      stopStage2FlashSfx(obj);
      el.classList.add("landed");
      // ensure prompt is readable
      const pEl = obj.promptEl || el.querySelector(".prompt");
      if(pEl) pEl.textContent = obj.prompt;
      const tEl = obj.tagEl || el.querySelector(".tag");
      if(tEl) tEl.textContent = "";
    }

    // EX1 Phase 2 ghost: add a visible marker while falling
    if(ex1Ghost){
      try{ obj.tagEl && (obj.tagEl.textContent = "👻"); }catch(_){/* ignore */}
    }
    setWordY(el, obj.y);
    wordsOnField.push(obj);
    return obj;
  }

  function spawnWordGroup(size){
    if(gameState !== "playing") return;
    const gid = nextGroupId++;

    // include current falling words (non-ghost) so groups don't overlap them
    const baseCount = wordsOnField.filter(w => (w.state === "landed") || (w.state === "falling" && !w.ex3Ghost)).length;

    const ids = [];
    for(let i=0;i<size;i++){
      const obj = spawnOneWord({
        state: "falling",
        y: -30 - 30 * i,
        groupId: gid,
        groupIndex: i,
        spawnBaseCount: baseCount,
      });
      if(obj) ids.push(obj.id);
    }
    ex4OnGroupSpawn(ids);
  }

  function spawnWord(){
    if(gameState !== "playing") return;

    // Extra Stage 4: phase-based spawning (none / doubles / triples)
    if(isExtraStage4()){
      if(!ex4SpawnEnabled) return;
      const size = ex4GroupSize();
      if(size > 1){
        spawnWordGroup(size);
      }else{
        spawnOneWord();
      }
      return;
    }

    // Default: single word
    spawnOneWord();
  }

  function normalizeAnswer(s){
    // Normalize input/answers to reduce "correct but marked wrong" edge cases
    // (mobile punctuation, full-width characters, zero-width spaces, etc.)
    return String(s)
      .normalize("NFKC")
      .replace(/[\u200B\u200C\u200D\uFEFF]/g, "")
      .trim()
      .toLowerCase()
      .replace(/\s+/g, " ")
      .replace(/[.,!?;:]+$/g, "");
  }

  function removeWord(id){
    const idx = wordsOnField.findIndex(w => w.id === id);
    if(idx === -1) return;
    try{ stopStage2FlashSfx(wordsOnField[idx]); }catch(_){/* ignore */}

    try{ s3ForbiddenIds && s3ForbiddenIds.delete(id); }catch(_){/* ignore */}
    wordsOnField[idx].el.remove();
    wordsOnField.splice(idx,1);
    restackDirty = true; // defer restack to next frame for performance
  }

  
  async function setBossVariant(stage, phase){
    let normal = stage.bossFile || "";

    if(phase === 2){
      normal = stage.bossFile2 || stage.bossFile || "";
    }else if(phase === 3){
      normal = stage.bossFile3 || stage.bossFile2 || stage.bossFile || "";
    }

    bossNormalSrc = normal;

    bossImg.style.display = "none";
    bossFallback.style.display = "grid";
    bossFallback.innerHTML =
      `${escapeHtml(stage.bossName || "Stage Boss")}<br>` +
      `<span style="color:var(--muted); font-weight:700; font-size:12px;">(${escapeHtml(normal || "boss.webp")} を置く)</span>` +
      `<br><span style="color:var(--muted); font-size:11px;">(同じフォルダ / GitHub Pages は大文字小文字を区別)</span>`;

    bossImg.onload = () => { bossImg.style.display = "block"; bossFallback.style.display = "none"; };
    bossImg.onerror = () => { bossImg.style.display = "none"; bossFallback.style.display = "grid"; };

    const nextBossSrc = bossNormalSrc || "";
    const prevBossAttr = bossImg.getAttribute("src") || "";
    bossImg.src = nextBossSrc;

    // If the src didn't change, some browsers won't fire onload again.
    // In that case, immediately sync visibility based on the already-loaded image.
    if(prevBossAttr === nextBossSrc && bossImg.complete){
      if(bossImg.naturalWidth > 0){
        bossImg.style.display = "block";
        bossFallback.style.display = "none";
      }else{
        bossImg.style.display = "none";
        bossFallback.style.display = "grid";
      }
    }
  }

  function showBossDamagedBriefly(){
    if(bossImg.style.display !== "block") return;

    // Flash once brightly (no sprite swapping).
    bossImg.classList.remove("bossFlash");
    void bossImg.offsetWidth;
    bossImg.classList.add("bossFlash");
  }

  async function setStageArt(stage){
    bgImg.style.display = "none";
    bgFallback.style.display = "block";
    bgImg.onload = () => { bgImg.style.display = "block"; bgFallback.style.display = "none"; };
    bgImg.onerror = () => { bgImg.style.display = "none"; bgFallback.style.display = "block"; };
    const nextBgSrc = stage.bgFile || "";
    const prevBgAttr = bgImg.getAttribute("src") || "";
    bgImg.src = nextBgSrc;

    // If the src didn't change, some browsers won't fire onload again.
    // In that case, immediately sync visibility based on the already-loaded image.
    if(prevBgAttr === nextBgSrc && bgImg.complete){
      if(bgImg.naturalWidth > 0){
        bgImg.style.display = "block";
        bgFallback.style.display = "none";
      }else{
        bgImg.style.display = "none";
        bgFallback.style.display = "block";
      }
    }

    // Stage 5 uses phase-based boss art (v1/v2/v3).
    let initialBossVariant = 1;
    if(currentMode === "normal" && stageIndex === 4){
      initialBossVariant = stage5BossVariantForPhase(stage5Phase || 1);
    }
    await setBossVariant(stage, initialBossVariant);
  }

  function nowMs(){ return performance.now(); }

  function stageElapsedSec(){
    if(!stagePlayStartMs) return 0;
    const base = nowMs() - stagePlayStartMs;
    const pausedSoFar = stagePausedTotalMs + (stagePauseStartMs ? (nowMs() - stagePauseStartMs) : 0);
    return Math.max(0, (base - pausedSoFar) / 1000);
  }

  function stage5DurationSec(){
    return (Number.isFinite(bgm.duration) && bgm.duration > 0) ? bgm.duration : null;
  }

  function stage5ResetPhase3Ramp(){
    s5p3SpawnMs = null;
    s5p3FallSpeed = null;
  }

  function stage5InitPhase3Ramp(){
    // Start Phase 3 at the base Stage 5 pacing.
    s5p3SpawnMs = STAGES[4].spawnEveryMs;
    s5p3FallSpeed = STAGES[4].fallSpeedPxPerSec;
  }

  function stage5Phase3RampOnBossHit(){
    if(!isNormalStage5()) return;
    if(stage5Phase !== 3) return;

    if(s5p3SpawnMs == null || s5p3FallSpeed == null){
      stage5InitPhase3Ramp();
    }

    // “A little” each hit:
    // - Shorten spawn interval slightly (higher spawn rate)
    // - Increase fall speed slightly
    s5p3SpawnMs = Math.max(450, Math.round(s5p3SpawnMs - 20));
    s5p3FallSpeed = Math.min(140, s5p3FallSpeed + 0.8);
  }

  function stage5CurrentFallSpeed(_elapsed){
    // Stage 5 phases are boss-HP-driven now (no BGM-time scaling).
    if(isNormalStage5() && stage5Phase === 3 && s5p3FallSpeed != null){
      return s5p3FallSpeed;
    }
    return STAGES[4].fallSpeedPxPerSec;
  }

  function stage5CurrentSpawnMs(_elapsed){
    // Stage 5 phases are boss-HP-driven now (no BGM-time scaling).
    if(isNormalStage5() && stage5Phase === 3 && s5p3SpawnMs != null){
      return s5p3SpawnMs;
    }
    return STAGES[4].spawnEveryMs;
  }

  async function stage5SetPhase(targetPhase){
    const stage = STAGES[4];
    if(stageIndex !== 4) return;
    if(targetPhase <= stage5Phase) return;

    for(let p = stage5Phase + 1; p <= targetPhase; p++){
      // On each phase transition: clear all spawned words that are NOT permafrost
      stage5ClearNonPermafrostWords();

      stage5Phase = p;


      if(p === 2){
      }
      const e = stageElapsedSec();
      if(p === 2 && stage5Phase2At == null) stage5Phase2At = e;
      if(p === 3 && stage5Phase3At == null) stage5Phase3At = e;

      // Phase 2/3: control Phase 3 ramp state
      if(p === 2){
        stage5ResetPhase3Ramp();
      }
      if(p === 3){
        stage5InitPhase3Ramp();
      }
      // Boss revives in Phase 2/3
      const phaseHp = (p === 2) ? 24 : (p === 3) ? 28 : bossMaxHp;
      bossMaxHp = phaseHp;
      bossHp = phaseHp;

      // Stage 5 timer no longer used
      showStage5Timer(false);

      await setBossVariant(stage, stage5BossVariantForPhase(p));
    }
    updateUI();
  }

  function handleStage5PhaseTriggers(){
    // Stage 5 phases are driven only by boss HP reaching 0.
  }

  async function stage5WinByBgmEnd(){
    if(stage5EndedHandled) return;
    stage5EndedHandled = true;

    setInputsEnabled(false);
    hideBossBubble();
    showStage5Timer(false);

    const stage = STAGES[stageIndex];
    await showStageClearScreen(stage);
    onVictory();
  }

  bgm.addEventListener("ended", () => {
    if(gameState !== "playing") return;

    const stage = STAGES[stageIndex];

    // Stage 5 (Normal): BGM ending does NOT clear the stage anymore.
    if(stageIndex === 4){
      return;
    }


    // EX Stage 4: win by BGM end
    if(stage && stage.endStageOnBgmEnd){
      (async () => {
        if(gameState !== "playing") return;
        setInputsEnabled(false);
        hideBossBubble();
        showStage5Timer(false);
        showEx4Timer(false);

        await showStageClearScreen(stage);
        onVictory();
      })();
    }
  });

  function findMatchAndClear(input){
    const norm = normalizeAnswer(input);
    if(!norm) return false;

    let best = null;
    let bestRank = -1;

    for(const w of wordsOnField){
      if(!w) continue;
      if((isNormalStage5() || isExtraStage1()) && w.s5Permafrost) continue;
      // answerNorm is cached on spawn/shuffle for speed + reliability
      if((w.answerNorm || normalizeAnswer(w.answer)) !== norm) continue;

      let rank = 0;
      if(isNormalStage5() && w.s5Highlighted && w.state === "landed" && !w.s5Permafrost) rank += 10;
      if(isNormalStage3() && w.s3Forbidden) rank = -5;
      if(isNormalStage1() && w.s1TwoHit){
        // Prioritize finishing an already "border-cleared" word, then clearing a fresh highlighted word.
        rank = ((w.s1HitCount|0) >= 1) ? 2 : 1;
      }

      if(rank > bestRank || (rank === bestRank && (!best || w.y > best.y))){
        best = w;
        bestRank = rank;
      }
    }

    if(!best){
      if(stage5IsFrozenInput(norm) || ex1IsFrozenInput(norm)){
        pushMsg("FROZEN", true);
        return true;
      }
      return false;
    }

    // Normal Stage 3: forbidden-highlighted words deal 1 damage if typed.
    // They get removed immediately and do NOT damage the boss.
    if(isNormalStage3() && best.s3Forbidden){
      pushMsg(`NG! 「${best.prompt}」→ ${best.answer}`);
      removeWord(best.id);
      damagePlayer(1, "stage3 forbidden typed");
      updateUI();
      return true;
    }

    // Normal Stage 1: highlighted words require two correct entries.
    // First correct input only removes the highlight border; the word stays.
    if(isNormalStage1() && best.s1TwoHit && ((best.s1HitCount|0) === 0)){
      best.s1HitCount = 1;
      try{ best.el && best.el.classList.remove("s1Target"); }catch(_){/* ignore */}
      pushMsg(`BREAK! 「${best.prompt}」→ ${best.answer}`);
      return true;
    }

    const pts = calcWordScore(best);
    addScore(pts);
    // XP gain: 1 XP per correct word
    try{ if(!(isEx2TrapPhase5 && isEx2TrapPhase5())) addXp(1); }catch(_){/* ignore */}

    const wasWakeUp = !!best.ex2WakeUp;
    removeWord(best.id);
    if(wasWakeUp){
      try{ ex2OnWakeUpCleared(); }catch(_){/* ignore */}
    }else if(isEx2TrapPhase5()){
      // EX2 Phase 5: after each successful clear (not wake-up), ramp the spawn rate.
      try{ ex2OnTrapWordCleared(); }catch(_){/* ignore */}
    }

    const dmg = baseHitDamage;
    damageBoss(dmg);

    pushMsg(`HIT! 「${best.prompt}」→ ${best.answer} (+${pts})`);

    // Boss can be invulnerable (EX4), so ensure score UI updates even if no HP changes.
    if(dmg <= 0) updateUI();
    return true;
  }

  function damageBoss(amount){
    if(amount <= 0) return;

    // EX2 Phase 5 trap: prevent boss damage (boss should never end the fake instance)
    try{ if(isEx2TrapPhase5 && isEx2TrapPhase5()) return; }catch(_){/* ignore */}

    // Extra Stage 2: boss takes no damage (stage clears when BGM ends)
    if(isExtraStage2()) return;

    const stage = STAGES[stageIndex] || null;
    if(currentMode === "practice" || (stage && stage.bossInvulnerable)){
      // Keep feedback, but do not change HP or clear the stage.
      playBossHitSfx();
      showBossDamagedBriefly();
      updateUI();
      return;
    }
    playBossHitSfx();
    showBossDamagedBriefly();

    bossHp = Math.max(0, bossHp - amount);

    // Normal Stage 5 (Phase 3): ramp difficulty slightly on every successful hit.
    if(isNormalStage5() && stage5Phase === 3){
      stage5Phase3RampOnBossHit();
    }

    // Normal Stage 3: when boss HP drops below half for the first time, randomize current falling words' speeds.
    if(isNormalStage3() && !s3HalfSpeedRandomized && bossHp < (bossMaxHp / 2)){
      s3HalfSpeedRandomized = true;
      for(const w of wordsOnField){
        if(!w || w.state !== "falling") continue;
        w.fallMult = stage3RandomFallMult();
      }
    }


    // Swap boss art when HP drops strictly below half (if stage.bossFile2 exists).
    // Normal: Stage 1–4 / Extra: EX Stage 1 & 3 (EX2 handles phases differently)
    const shouldAutoSwapBelowHalf =
      (currentMode === "normal" && stageIndex >= 0 && stageIndex <= 3);

    if(shouldAutoSwapBelowHalf &&
       bossVariantPhase === 1 && bossHp > 0 && bossHp < (bossMaxHp / 2) &&
       (stage?.bossFile2)){
      bossVariantPhase = 2;
      // async swap; no need to await here
      setBossVariant(stage, 2);
    }

    if(!midFightBubbleShown && stageIndex >= 0 && stageIndex <= 3 && !(currentMode === "extra" && stageIndex === 1)){
      if(stage?.midFightDialogue && bossHp > 0 && bossHp <= (bossMaxHp / 2)){
        midFightBubbleShown = true;
        showBossBubble(stage.midFightDialogue, 5000);
      }
    }

    updateUI();

    if(bossHp === 0){
      // Extra Stage 2: survival stage — ignore boss HP (clear ONLY on BGM end)
      if(isExtraStage2()){
        return;
      }
      // Extra Stage 1: Phase 1 -> Phase 2 revive
      if(isExtraStage1() && ex1Phase === 1){
        ex1EnterPhase2();
        return;
      }
      if(stageIndex === 4){
        // Normal Stage 5: Phase 1 -> Phase 2 -> Phase 3, then clear on Phase 3 boss down
        if(stage5Phase < 3){
          stage5SetPhase(stage5Phase + 1);
          return;
        }
        onBossDefeated();
        return;
      }
      onBossDefeated();
    }
  }


  function pauseStageClock(){
    if(stagePauseStartMs == null) stagePauseStartMs = nowMs();
  }
  function resumeStageClock(){
    if(stagePauseStartMs != null){
      stagePausedTotalMs += (nowMs() - stagePauseStartMs);
      stagePauseStartMs = null;
    }
  }

  function cleanupPauseListeners(){
    if(!pauseListeners) return;
    try{ overlayChoices.removeEventListener("click", pauseListeners.onChoiceClick); }catch(_){/* ignore */}
    pauseListeners = null;
  }

  function showPauseOverlay(){
    showOverlay(true);
    overlay.style.cursor = "default";
    overlayTitle.textContent = "Paused";
    overlayDesc.textContent = "ゲームを一時停止中";
    overlayHint.textContent = "ESC または Pause で再開";
    countdownText.textContent = "";

    overlayChoices.classList.add("show");
    overlayChoices.innerHTML = `
      <div class="choiceBtn" data-act="resume">
        <div class="title">Resume</div>
        <div class="desc">ゲームを再開</div>
        <div class="note">ESC</div>
      </div>
    `;

    const onChoiceClick = (e) => {
      const btn = e.target.closest(".choiceBtn");
      if(!btn) return;
      const act = btn.getAttribute("data-act");
      if(act === "resume") resumeGame(true);
    };

    cleanupPauseListeners();
    pauseListeners = { onChoiceClick };
    overlayChoices.addEventListener("click", onChoiceClick);
  }

  function pauseGame(){
    if(gameState !== "playing") return;

    // Safety: if a resume countdown was somehow running, stop it.
    clearResumeCountdown();
    if(isExtraStage2()){
      pushMsg("⛔ Pause disabled in EX Stage 2", true);
      return;
    }

    gameState = "paused";
    pauseStageClock();

    pausedBgmState = {
      src: currentBgm || (bgm.currentSrc || ""),
      time: Number.isFinite(bgm.currentTime) ? bgm.currentTime : 0,
      loop: !!bgm.loop,
      wasPlaying: !bgm.paused
    };
    try{ bgm.pause(); }catch(_){/* ignore */}

    // Disable input but keep what the user already typed.
    setInputsEnabledSoft(false);

    pushMsg("⏸ PAUSED", true);
    showPauseOverlay();
    updateUI();
  }

  function finishResumeGame(fromGesture=false){
    if(gameState !== "paused") return;

    clearResumeCountdown();

    cleanupPauseListeners();

    gameState = "playing";
    resumeStageClock();

    showOverlay(false);
    try{
      overlayChoices.classList.remove("show");
      overlayChoices.innerHTML = "";
    }catch(_){/* ignore */}
    overlay.style.cursor = "pointer";

    setInputsEnabledSoft(true);

    // Restore BGM (resume same track/time)
    try{
      if(pausedBgmState && pausedBgmState.src){
        const wantSrc = pausedBgmState.src;
        const curSrc = currentBgm || (bgm.currentSrc || "");
        if(curSrc !== wantSrc){
          setBgm(wantSrc, pausedBgmState.loop, false);
        }
        try{ bgm.currentTime = Math.max(0, pausedBgmState.time || 0); }catch(_){/* ignore */}
        if(pausedBgmState.wasPlaying){
          if(fromGesture) tryPlayBgmFromGesture();
          else tryPlayBgm();
        }
      }
    }catch(_){/* ignore */}
    pausedBgmState = null;

    pushMsg("▶ RESUME", true);
    updateUI();
  }

  
  // --- Resume countdown (3s) ---
  let resumeCountdownTimer = null;
  function clearResumeCountdown(){
    if(resumeCountdownTimer){
      clearInterval(resumeCountdownTimer);
      resumeCountdownTimer = null;
    }
    try{ countdownText.textContent = ""; }catch(_){/* ignore */}
  }


  function startResumeCountdown(fromGesture=false){
    if(gameState !== "paused") return;
    if(resumeCountdownTimer) return;

    // The user already "unpaused" — hide the Paused message and show a countdown.
    try{
      overlayTitle.textContent = "";
      overlayDesc.textContent  = "";
      overlayHint.textContent  = "Resuming in...";
      overlayChoices.classList.remove("show");
      overlayChoices.innerHTML = "";
      overlay.style.cursor = "default";
    }catch(_){/* ignore */}

    // Prime audio during the gesture tick so iOS/Safari is less likely to block resume later.
    if(fromGesture){
      try{
        const t = (Number.isFinite(bgm.currentTime) ? bgm.currentTime : 0);
        const wasMuted = !!bgm.muted;
        const wasVol = Number.isFinite(bgm.volume) ? bgm.volume : 1;
        try{ bgm.muted = true; }catch(_){/* ignore */}
        try{ bgm.play(); }catch(_){/* ignore */}
        try{ bgm.pause(); }catch(_){/* ignore */}
        try{ bgm.currentTime = t; }catch(_){/* ignore */}
        try{ bgm.muted = wasMuted; }catch(_){/* ignore */}
        try{ bgm.volume = wasVol; }catch(_){/* ignore */}
      }catch(_){/* ignore */}
    }

    let n = 3;
    countdownText.textContent = String(n);

    resumeCountdownTimer = setInterval(() => {
      if(gameState !== "paused"){
        clearInterval(resumeCountdownTimer);
        resumeCountdownTimer = null;
        countdownText.textContent = "";
        return;
      }

      n -= 1;
      if(n <= 0){
        clearInterval(resumeCountdownTimer);
        resumeCountdownTimer = null;
        countdownText.textContent = "";
        // Not a gesture anymore: rely on the earlier prime + normal play().
        finishResumeGame(false);
      }else{
        countdownText.textContent = String(n);
      }
    }, 1000);
  }

  function resumeGame(fromGesture=false){
    startResumeCountdown(fromGesture);
  }

function togglePause(fromGesture=false){
    if(gameState === "paused") resumeGame(fromGesture);
    else if(gameState === "playing") pauseGame();
  }

function damagePlayer(amount, reason){
    if(amount <= 0) return;

    const scaled = Math.max(1, Math.round(amount));
    damageTakenThisStage += scaled;
    damageTakenThisRun += scaled;
    playerHp = Math.max(0, playerHp - scaled);
    playPlayerHitSfx();
    flashPlayerDamage();
    pushMsg(`Player takes ${scaled} dmg (${reason})`, true);
    updateUI();

    if(playerHp === 0) onPlayerDeath();
  }

  function cleanupContinueListeners(){
    if(!continueListeners) return;
    window.removeEventListener("keydown", continueListeners.onKey);
    overlayChoices.removeEventListener("click", continueListeners.onChoiceClick);
    continueListeners = null;
  }

  function showContinuePrompt(){
    gameState = "continuePrompt";
    setInputsEnabled(false);
    showStage5Timer(false);
    pauseStageClock();

    saveBgmState();
    setBgm(AUDIO.deathBgm, true);

    continuePromptUntilMs = nowMs() + (CONTINUE_DECISION_SEC * 1000);

    showOverlay(true);
    overlay.style.cursor = "default";
    overlayTitle.textContent = "CONTINUE?";
    const cLabel = (currentMode === "practice") ? "∞" : String(continuesLeft);
    overlayDesc.textContent = `残りコンティニュー：${cLabel}（HP +3）`;
    overlayHint.textContent = "10秒以内に選択";
    overlayChoices.classList.add("show");
    overlayChoices.innerHTML = `
      <div class="choiceBtn" data-act="continue">
        <div class="title">Continue</div>
        <div class="desc">HPを3にして再開（積み上がった単語を全消去）</div>
        <div class="note">残り：${cLabel}</div>
      </div>
      <div class="choiceBtn" data-act="reset">
        <div class="title">Reset</div>
        <div class="desc">最初からやり直し（バフ選択から）</div>
      </div>
    `;

    const onChoiceClick = (e) => {
      const btn = e.target.closest(".choiceBtn");
      if(!btn) return;
      const act = btn.getAttribute("data-act");
      if(act === "continue") useContinue();
      if(act === "reset") hardLoseToReset();
    };

    const onKey = (e) => {
      if(e.key === "Enter"){
        e.preventDefault();
        useContinue();
      } else if(e.key === "Escape"){
        e.preventDefault();
        hardLoseToReset();
      }
    };

    continueListeners = { onChoiceClick, onKey };
    overlayChoices.addEventListener("click", onChoiceClick);
    window.addEventListener("keydown", onKey);

    updateContinueCountdownText();
  }

  function updateContinueCountdownText(){
    if(gameState !== "continuePrompt") return;
    const remMs = continuePromptUntilMs - nowMs();
    const rem = Math.max(0, Math.ceil(remMs / 1000));
    countdownText.textContent = String(rem);
    if(rem <= 0){
      hardLoseToReset();
    }
  }

  function useContinue(){
    if(gameState !== "continuePrompt") return;
    if(continuesLeft <= 0){
      hardLoseNoContinues();
      return;
    }

    if(currentMode !== "practice"){
      continuesLeft -= 1;
      continuesUsedThisRun += 1;
    }

    cleanupContinueListeners();
    showOverlay(false);

    resetField({ preservePermafrost: (isNormalStage5() || isExtraStage1()) });

    playerHp = Math.min(playerMaxHp, 3);
    overflowAcc = 0;
    overflow = false;

    resumeStageClock();
    restoreBgmState();

    const cLabel = (currentMode === "practice") ? "∞" : String(continuesLeft);
    pushMsg(`▶ CONTINUE! HP=${playerHp} / 残り${cLabel} / Penalty×${scorePenaltyMultiplier().toFixed(2)}`, true);

    gameState = "playing";
    setInputsEnabled(true);
    updateUI();
  }

  function hardLoseNoContinues(){
    cleanupContinueListeners();
    gameState = "gameover";
    setInputsEnabled(false);
    hideBossBubble();
    showStage5Timer(false);
    pauseStageClock();

    setBgm(AUDIO.deathBgm, true);

    showOverlay(true);
    overlay.style.cursor = "pointer";
    setOverlayText("GAME OVER", "コンティニュー切れ。Resetで最初から（バフ選択から）", "（クリックでもOK）");
    pushMsg("💀 GAME OVER（コンティニュー切れ）");
  }

  function hardLoseToReset(){
    cleanupContinueListeners();
    resetGame();
  }

  function onPlayerDeath(){
    if(gameState !== "playing") return;

    // EX2 trap: losing loops back instantly
    if(isEx2TrapActive()){
      ex2ResetTrapInstance();
      return;
    }

    if(continuesLeft > 0){
      pushMsg("💀 DOWN... コンティニューしますか？", true);
      showContinuePrompt();
      return;
    }
    hardLoseNoContinues();
  }

  function showBossDialogue(stage, flowToken){
    return new Promise((resolve) => {
      const token = (typeof flowToken === "number") ? flowToken : uiFlowToken;
      if(!isUiFlow(token)) return resolve(false);

      gameState = "dialogue";
      setInputsEnabled(false);

      setBgm(stage.dialogueBgmFile, true);

      showOverlay(true);
      setOverlayText(stage.bossName, stage.bossDialogue || "……", "▶ Enter または クリックで進む");
      countdownText.textContent = "";

      let done = false;
      const finish = (ok) => {
        if(done) return;
        done = true;
        removeCancel();
        cleanup();
        try{ showOverlay(false); }catch(_){/* ignore */}
        resolve(!!ok);
      };

      const proceed = () => finish(true);
      const onKey = (e) => { if(e.key === "Enter"){ e.preventDefault(); proceed(); } };
      const onClick = () => proceed();

      const cleanup = () => {
        window.removeEventListener("keydown", onKey);
        overlay.removeEventListener("click", onClick);
      };

      const removeCancel = addUiFlowCleanup(() => finish(false));

      window.addEventListener("keydown", onKey);
      overlay.addEventListener("click", onClick);
    });
  }

  async function countdown(seconds, flowToken){
    const token = (typeof flowToken === "number") ? flowToken : uiFlowToken;
    if(!isUiFlow(token)) return false;

    gameState = "countdown";
    setInputsEnabled(false);

    showOverlay(true);
    setOverlayText("READY?", "カウントダウン後に開始", "");
    for(let s=seconds; s>=1; s--){
      if(!isUiFlow(token) || gameState !== "countdown") return false;
      countdownText.textContent = String(s);
      await sleep(650);
    }
    if(!isUiFlow(token) || gameState !== "countdown") return false;
    countdownText.textContent = "GO!";
    await sleep(420);
    if(!isUiFlow(token) || gameState !== "countdown") return false;
    showOverlay(false);
    return true;
  }

  function showStageClearScreen(stage){
    return new Promise((resolve) => {
      gameState = "stageclear";
      setInputsEnabled(false);

      const stageClearBgm = (currentMode === "extra") ? AUDIO.extraVictoryBgm : AUDIO.victoryBgm;
      setBgm(stageClearBgm, true);

      showOverlay(true);
      setOverlayTitleStageClear(stage.stageName);
      overlayDesc.textContent = `${stage.stageName} クリア！`;
      overlayHint.textContent = "▶ クリック/Enter で次へ（自動でも進みます）";
      countdownText.textContent = "";
      overlayChoices.classList.remove("show");
      overlayChoices.innerHTML = "";

      let allowSkip = false;
      const minShowT = setTimeout(() => { allowSkip = true; }, 450);

      let done = false;
      const finish = () => {
        if(done) return;
        done = true;
        cleanup();
        showOverlay(false);
        resolve();
      };

      const autoT = setTimeout(() => { allowSkip = true; finish(); }, 2200);

      const onKey = (e) => {
        if(e.key === "Enter"){
          e.preventDefault();
          if(!allowSkip) return;
          clearTimeout(autoT);
          finish();
        }
      };
      const onClick = () => {
        if(!allowSkip) return;
        clearTimeout(autoT);
        finish();
      };

      const cleanup = () => {
        clearTimeout(minShowT);
        window.removeEventListener("keydown", onKey);
        overlay.removeEventListener("click", onClick);
      };

      window.addEventListener("keydown", onKey);
      overlay.addEventListener("click", onClick);
    });
  }

  async function startStage(idx){
    const flow = cancelUiFlow();
    // Failsafe: clamp stage index to available stages (prevents undefined stage crashes)
    const maxIdx = Math.max(0, ((STAGES && STAGES.length) ? STAGES.length : 1) - 1);
    idx = Math.max(0, Math.min(maxIdx, Math.trunc(Number(idx) || 0)));
    stageIndex = clamp(idx, 0, Math.max(0, STAGES.length - 1));
    resetField();
    damageTakenThisStage = 0;
    hideBossBubble();

    spawnAccMs = 0;
    autoSpawnEnabled = true;
    spawnCountThisStage = 0;
    midFightBubbleShown = false;

    // Normal Stage 3 reset
        s3HalfSpeedRandomized = false;
    stage3InitForbiddenCycle();
    showStage5Timer(false);

    const stage = STAGES[idx];

    stagePlayStartMs = 0;
    stagePausedTotalMs = 0;
    stagePauseStartMs = null;

    if(idx === 4){
      stage5Phase = 1;
    stage5EndedHandled = false;
    stage5Phase2At = null;
    stage5Phase3At = null;
    stage5ResetPhase3Ramp();
      stage5ResetPhase3Ramp();
      showStage5Timer(false);
    }

    bossMaxHp = stage.bossMaxHp;
    bossHp = stage.bossMaxHp;
    bossVariantPhase = 1;
    baseHitDamage = stage.hitDamage;

    // Extra Stage 1: Phase 1 starts at 34 HP
    if(isExtraStage1()){
      ex1Phase = 1;
      bossMaxHp = 34;
      bossHp = 34;
      bossVariantPhase = 1;
      // async swap; no need to await
      try{ setBossVariant(stage, 1); }catch(_){/* ignore */}
    }

    await setStageArt(stage);
    if(!isUiFlow(flow)) return;

    updateUI();

    msgBox.innerHTML = "";
    pushMsg(`${stage.stageName} 開始！`);
    pushMsg(`Boss: ${stage.bossName}`, true);
    pushMsg(`Continues: ${continuesLeft}/${MAX_CONTINUES}`, true);

    const okDialogue = await showBossDialogue(stage, flow);
    if(!okDialogue || !isUiFlow(flow)) return;

    const okCountdown = await countdown(3, flow);
    if(!okCountdown || !isUiFlow(flow)) return;

    gameState = "playing";
    setInputsEnabled(true);

    stagePlayStartMs = nowMs();

    // Normal Stage 4: start the 5s/3s cycle timer once play begins
    if(isNormalStage4()){
      stage4InitCycleTimer();
    }else{
      stage4CycleLeftSec = 0;
      stage4CycleIntervalSec = 5;
      stage4FreezeLeftSec = 0;
      stage4FreezeTarget = null;
      stage4ClearFreezeTimeouts();
    }

    // Extra Stage 2: time-based phases
    // Phase 1: 0–40s, Phase 2: 40–68s, Phase 3: 68–98s, Phase 4: 98–130s, Phase 5: 130s+
    if(isExtraStage2()){
      ex2Phase = 1;
      ex2Phase2Announced = false;
      ex2Phase3Announced = false;
      ex2Phase4Announced = false;
      ex2Phase5Announced = false;
      ex2PhaseSpawnCount = 0;
    }else{
      ex2Phase = 0;
      ex2Phase2Announced = false;
      ex2Phase3Announced = false;
      ex2Phase4Announced = false;
      ex2Phase5Announced = false;
      ex2PhaseSpawnCount = 0;
    }

    // Extra Stage 4: always reset + enter Phase 1 right after the countdown
    if(isExtraStage4()){
      ex4Phase = 0;
      ex4SpawnEnabled = false;
      ex4ClearShuffleState();
      ex4ShowFakeDeath(false);
      showEx4Timer(true);
      ex4HandlePhaseEnter(1);
    }else{
      showEx4Timer(false);
      ex4Phase = 0;
      ex4SpawnEnabled = false;
      ex4ClearShuffleState();
      ex4ShowFakeDeath(false);
    }

    startEx2Mechanic();
    stagePausedTotalMs = 0;
    stagePauseStartMs = null;

    spawnAccMs = 0;

    setBgm(stage.playBgmFile, stage.playBgmLoop !== false);

    // Extra Stage 2: survival clear — activate "clear on BGM end"
    if(isExtraStage2()){
      ex2ClearOnBgmEndActive = true;
      ex2ClearOnBgmEndSrc = stage.playBgmFile || "";
    }else{
      ex2ClearOnBgmEndActive = false;
      ex2ClearOnBgmEndSrc = "";
    }
  }

  async function startGame(){
    cleanupContinueListeners();
    resetField();
    hideBossBubble();
    showStage5Timer(false);

    stageIndex = 0;
    mistakes = 0;

    continuesLeft = (currentMode === "practice") ? Infinity : MAX_CONTINUES;
    resetRunScoring();

    playerMaxHp = BASE_PLAYER_MAX_HP;
    playerHp = playerMaxHp;


    showOverlay(false);
    await startStage(0);
  }

  // ---- Global jump to the *first launch* intro screen (LOAD → START) ----
  // Used by the memory wipe cheat and can be safely called from anywhere.
  function hardResetCoreToIdle(){
    cleanupContinueListeners();
    cleanupPauseListeners();
    clearResumeCountdown();
    pausedBgmState = null;
    setNegativeMode(false);
    setDreamLike(false);

    setMode("normal");
    normalCleared = loadNormalCleared();

    // Restart resets score + penalty
    resetAllRunScoring();

    gameState = "idle";
    resetField();
    hideBossBubble();
    showStage5Timer(false);

    spawnAccMs = 0;
    spawnCountThisStage = 0;

    midFightBubbleShown = false;


    playerMaxHp = BASE_PLAYER_MAX_HP;
    playerHp = playerMaxHp;
    mistakes = 0;
    stageIndex = 0;
    bossHp = 0;
    bossMaxHp = 0;
    bossVariantPhase = 1;

    continuesLeft = (currentMode === "practice") ? Infinity : MAX_CONTINUES;
    continuePromptUntilMs = 0;

    stagePlayStartMs = 0;
    stagePausedTotalMs = 0;
    stagePauseStartMs = null;

    stage5Phase = 1;
    stage5EndedHandled = false;
    stage5Phase2At = null;
    stage5Phase3At = null;

    stopBgm();
    try{ setStageArt(STAGES[0]); }catch(_){/* ignore */}

    // Hide the in-game overlay (mode select, dialogue, etc.) so the intro can be seen.
    showOverlay(false);
    try{
      overlayChoices.classList.remove("show");
      overlayChoices.innerHTML = "";
    }catch(_){/* ignore */}

    setInputsEnabled(false);
    updateUI();
  }

  function goToFirstLaunchScreen(noteText){
    hardResetCoreToIdle();

    // Clear message log (optional)
    try{ msgBox.innerHTML = ""; }catch(_){/* ignore */}
    pushMsg("START MENU");
    pushMsg("LOAD → START", true);

    // Force-show the intro overlay even if it has already been shown once.
    showIntroStartScreen(true);

    // Show a note to confirm the wipe happened.
    try{
      if(noteText) introNote.textContent = noteText;
    }catch(_){/* ignore */}
  }


  function resetGame(){
    cleanupContinueListeners();
    cleanupPauseListeners();
    clearResumeCountdown();
    pausedBgmState = null;
    setNegativeMode(false);
    setDreamLike(false);
    if(gameState === "paused"){ try{ showOverlay(false); }catch(_){/* ignore */} }

    // EX2 trap: Reset / Run (Reset) loops back into the fake instance
    if(isEx2TrapActive()){
      ex2ResetTrapInstance();
      return;
    }

    // EX4 Phase 4: completely block reset/run (fake death lockout)
    if(gameState === "playing" && isExtraStage4() && ex4Phase === 4){
      ex4ShowFakeDeath(true);
      overlayDesc.textContent = "HAHAHAHAHAHA";
      ex4PlayResetScare();
      return;
    }

    // Cancel any in-progress async UI flow (countdown/dialogue/etc.) so it can’t resume after reset.
    cancelUiFlow();

    // Helper: wipe state back to a clean idle baseline (no screen shown yet)
    function hardResetCore(){
      setMode("normal");
      normalCleared = loadNormalCleared();

      // Restart resets score + penalty
      resetAllRunScoring();

      gameState = "idle";
      resetField();
      hideBossBubble();
      showStage5Timer(false);

      spawnAccMs = 0;
      spawnCountThisStage = 0;

      // Normal Stage 3 baseline reset
      s3HalfSpeedRandomized = false;
      stage3InitForbiddenCycle();
      midFightBubbleShown = false;


      playerMaxHp = BASE_PLAYER_MAX_HP;
      playerHp = playerMaxHp;
      mistakes = 0;
      stageIndex = 0;
      bossHp = 0;
      bossMaxHp = 0;
      bossVariantPhase = 1;

      continuesLeft = (currentMode === "practice") ? Infinity : MAX_CONTINUES;
      continuePromptUntilMs = 0;

      stagePlayStartMs = 0;
      stagePausedTotalMs = 0;
      stagePauseStartMs = null;

      stage5Phase = 1;
      stage5EndedHandled = false;
      stage5Phase2At = null;
      stage5Phase3At = null;

      stopBgm();
      setStageArt(STAGES[0]);

      setInputsEnabled(false);
      updateUI();
    }

    function goToModeSelect(){
      hardResetCore();

      msgBox.innerHTML = "";
      pushMsg("MODE SELECT");
      pushMsg("Start → モード選択 → バフ選択 → ステージ開始", true);
      pushMsg(normalCleared ? "Extra Mode: UNLOCKED" : "Extra Mode: LOCKED（Normal クリアで解放）", true);

      showModeSelectScreen();
    }

    function goToStartMenuTitle(){
      hardResetCore();

      // Ensure the in-game overlay is hidden; the title screen will cover everything.
      showOverlay(false);

      msgBox.innerHTML = "";
      pushMsg("START MENU");
      pushMsg("LOAD → START", true);

      // Show the same start menu you see on first launch (force re-show).
      showIntroStartScreen(true);
    }

    // Victory screen Reset behavior:
    // - ONLY on the player's FIRST ever clear of Stage 5 (Normal): send them back to the START/TITLE menu once.
    if(gameState === "victory"){
      if(victoryResetToStartMenuOnce){
        victoryResetToStartMenuOnce = false; // consume
        goToStartMenuTitle();
        return;
      }else{
        victoryResetToStartMenuOnce = false;
        setMode("normal");
        startGame();
        return;
      }
    }

    // Default reset path: back to MODE SELECT
    goToModeSelect();
  }

  function onBossDefeated(){
    if(gameState !== "playing") return;

    // EX2 trap: boss defeat loops back into the fake instance
    if(isEx2TrapActive()){
      ex2ResetTrapInstance();
      return;
    }

    // Ensure EX2 survival flag doesn't linger into clear screens/next stages
    ex2ClearOnBgmEndActive = false;
    ex2ClearOnBgmEndSrc = "";

    setInputsEnabled(false);
    hideBossBubble();
    pushMsg("✅ Boss defeated!");

    (async () => {
      const clearedStage = STAGES[stageIndex];
      const isFinal = (stageIndex === STAGES.length - 1);

      await showStageClearScreen(clearedStage);

      try{ checkChallengeAchievementsAfterStageClear(); }catch(_){/* ignore */}


      if(isFinal){
        onVictory();
      }else{
        stageIndex++;
        await startStage(stageIndex);
      }
    })();
  }

  function onVictory(){
  cleanupContinueListeners();
  gameState = "victory";
  setInputsEnabled(false);
  hideBossBubble();
  showStage5Timer(false);

  // Track whether this was the player's FIRST ever clear of Stage 5 (Normal).
  // We will use this once: if they hit Reset from the victory screen, send them back to the start menu.
  victoryResetToStartMenuOnce = (currentMode === "normal" && !normalCleared);

  // If Normal mode was cleared, unlock Extra permanently
  if(currentMode === "normal" && !normalCleared){
    normalCleared = true;
    saveNormalCleared();
    try{ unlockAchievement("normal_clear"); }catch(_){/* ignore */}
    try{ if(loadExtraCleared()) unlockAchievement("master_clear"); }catch(_){/* ignore */}
    pushMsg("🔓 EXTRA MODE unlocked!（Normal クリア）", true);
  }

  // If Extra mode was cleared for the first time, unlock the Master intro (Normal + Extra clear).
  // (Extra is normally only accessible after Normal clear, but debug mode may bypass that.)
  if(currentMode === "extra" && !extraCleared){
    extraCleared = true;
    saveExtraCleared();
    try{ unlockAchievement("extra_clear"); }catch(_){/* ignore */}
    try{ if(loadNormalCleared()) unlockAchievement("master_clear"); }catch(_){/* ignore */}
    pushMsg("🏆 MASTER INTRO unlocked!（Normal + Extra クリア）", true);
  }


  const victoryBgmFile = (currentMode === "extra") ? AUDIO.extraVictoryBgm : AUDIO.victoryBgm;
  setBgm(victoryBgmFile, true);

  const clearedCount = STAGES.length;
  const desc = (currentMode === "extra")
    ? `${clearedCount}ステージクリア！（Extra）Resetで再スタート`
    : (victoryResetToStartMenuOnce
        ? `${clearedCount}ステージクリア！（Normal）Resetでスタート画面へ戻る / Extra 解放！`
        : `${clearedCount}ステージクリア！（Normal）Resetで再スタート${normalCleared ? " / Extra 解放！" : ""}`);

  showOverlay(true);
  setOverlayText("VICTORY!", desc, "Reset で再スタート");
  pushMsg("🏆 VICTORY!");
}

  async function cheatSkipToStage5(){
    if(currentMode !== "normal" || STAGES.length < 5){
      pushMsg("CHEAT: Normal Mode のみ対応", true);
      return;
    }
    if(stageIndex === 4){
      pushMsg("CHEAT: すでにStage 5です", true);
      return;
    }

    pushMsg("CHEAT: Stage 5へスキップ！", true);

    resetField();
    hideBossBubble();
    showStage5Timer(false);
    showOverlay(false);

    playerHp = clamp(playerHp, 1, playerMaxHp);
    updateUI();

    stageIndex = 4;
    await startStage(4);
  }

  function submitAnswer(){
    if(gameState !== "playing") return;

    // Normal Stage 4: allow typing during the freeze, but block submissions until it ends.
    if(isNormalStage4() && stage4IsFrozen()){
      // Keep the typed text in the box; just ignore the submit.
      if(!stage4SubmitBlockedThisFreeze){
        stage4SubmitBlockedThisFreeze = true;
        pushMsg("⏸ 凍結中…", true);
      }
      return;
    }

    const raw = answerInput.value.trim();
    answerInput.value = "";

    const rawLower = raw.toLowerCase();
    if(rawLower === DEBUG_MODE_CODE){
      debugMode = true;
      saveDebugMode(true);
      pushMsg("🛠 DEBUG MODE ON", true);
      showDebugStagePicker();
      return;
    }


    // Cheat: wipe all saved memory (unlock + hi-scores + debug flags)
    if(rawLower === CHEAT_MEMORY_WIPE){
      wipeGameMemory();
      pushMsg("🧹 MEMORY WIPED (bossTyping_*)", true);

      // Return to the *very first launch* intro screen (LOAD → START).
      // NOTE: This must be a top-level helper (not inside resetGame), so cheats can call it from anywhere.
      goToFirstLaunchScreen("🧹 セーブデータを削除しました (MEMORY WIPED)");
      return;
    }

    // Cheat: +100,000 coins
    if(rawLower === CHEAT_MONEY){
      try{ addCoins(CHEAT_MONEY_AMOUNT); }catch(_){/* ignore */}
      try{ pushMsg(`💰 +${fmtCoins(CHEAT_MONEY_AMOUNT)} coins!`, true); }catch(_){/* ignore */}
      try{ renderProfileHeader(); }catch(_){/* ignore */}
      return;
    }

    if(raw === CHEAT_SKIP_STAGE5){
      cheatSkipToStage5();
      return;
    }
    const norm = normalizeAnswer(raw);

    const ok = findMatchAndClear(raw);
    if(!ok){
      mistakes++;
      pushMsg(`MISS: ${raw || "(blank)"}`);
      damagePlayer(1, "input miss");
      updateUI();
    }

    answerInput.focus();
  }

  // Throttle the main loop while in menus/paused states to reduce CPU/GPU usage.
  const IDLE_TICK_MS = 120; // ~8fps
  function scheduleTick(idle){
    if(idle) setTimeout(() => requestAnimationFrame(tick), IDLE_TICK_MS);
    else requestAnimationFrame(tick);
  }

  function tick(ts){
    let dt = 0;
    if(lastTs){
      const rawDt = (ts - lastTs) / 1000;
      const MAX_DT = 0.2;
      dt = Math.min(rawDt, MAX_DT);
      const lost = rawDt - dt;
      if(lost > 0 && gameState === "playing" && stagePlayStartMs){
        // Keep stage timers in sync with simulation when frames hitch.
        stagePausedTotalMs += lost * 1000;
      }
    }
    lastTs = ts;

    const dtReal = dt;
    // Normal Stage 4: world-freeze window when the switch happens
    stage4UpdateFreeze(dtReal);
    if(gameState === 'playing' && isNormalStage4() && stage4IsFrozen()){
      dt = 0;
    }

    // EX2 Phase 5 hard-switch visual: negative colors once 8 clears is reached.
    setNegativeMode(isEx2TrapPhase5() && ((ex2FakeCorrectCount|0) >= 8));

    if(gameState === "continuePrompt"){
      updateContinueCountdownText();
      updateUIThrottled();
      scheduleTick(true);
      return;
    }

if(gameState === "paused"){
  // Freeze simulation & mechanics while paused.
  scheduleTick(true);
  return;
}

    if(gameState === "playing"){
      const stage = STAGES[stageIndex];
      const elapsed = stageElapsedSec();
      ex4HandlePhaseTriggers(elapsed);
      ex2HandlePhaseTriggers(elapsed);
      updateEx2TrapRuntime();

      spawnAccMs += dt * 1000;
      let spawnMs = stage.spawnEveryMs;
      if(stageIndex === 4){
        spawnMs = stage5CurrentSpawnMs(elapsed);
      }

      // EX Stage 4: Phase-based spawn rate adjustment
      // Phases 2–3: 55% of original spawn rate (=> longer interval)
      // Phase 5: 2x 10% slower than phases 2–3 (i.e., 44.55% of original)
      const isEx4 = isExtraStage4();
      const ex4Adj = isEx4 && (ex4Phase === 2 || ex4Phase === 3 || ex4Phase === 5);
      if(isEx4 && (ex4Phase === 2 || ex4Phase === 3)){
        spawnMs = Math.round(spawnMs / 0.55);
      }else if(isEx4 && ex4Phase === 5){
        spawnMs = Math.round(spawnMs / 0.55 / 0.9 / 0.9);
      }


      // EX Stage 3: After boss HP drops below half, increase spawn rate by 15% (shorter interval)
      if(isExtraStage3() && (bossHp < (bossMaxHp / 2))){
        spawnMs = Math.max(250, Math.round(spawnMs / 1.15));
      }

      // EX2 Phase 5 trap: spawn pacing step (0..7 clears = 50% rate, 8+ clears = 5x rate)
      if(isEx2TrapPhase5() && !ex2WakeUpActive){
        spawnMs = Math.max(120, Math.round(spawnMs * ex2TrapSpawnMultiplier()));
      }
      if(!autoSpawnEnabled){
        // Disabled spawns (used by EX2 Phase 5 wake-up stack)
        spawnAccMs = 0;
      }else{
        let loops = 0;
        while(spawnAccMs >= spawnMs && loops < 6){
          spawnWord();
          spawnAccMs -= spawnMs;
          loops++;
        }
      }

      const h = laneHeight();
      let fallSpeed = (stageIndex === 4)
        ? stage5CurrentFallSpeed(elapsed)
        : stage.fallSpeedPxPerSec;

      // EX Stage 4: Phase 2/3/5 fall speed adjustment (+10% of original)
      if(ex4Adj){
        fallSpeed *= 1.10;
      }

      // EX2 Phase 5 trap: at 8 clears, hard-switch to 5x Normal Stage 1 fall speed (no incremental ramp)
      if(isEx2TrapPhase5() && !ex2WakeUpActive && ((ex2FakeCorrectCount|0) >= 8)){
        fallSpeed *= 5;
      }


      // Normal Stage 3: timer-based forbidden selection
      stage3UpdateCycle(dt);

      // PERF: Avoid repeated .filter() inside the per-word loop.
      const words = wordsOnField;
      let landedCount = 0;
      for(let i=0;i<words.length;i++){
        if(words[i].state === "landed") landedCount++;
      }

      let needsRestack = restackDirty;
      restackDirty = false;

      for(let i=0;i<words.length;i++){
        const w = words[i];
        if(w.state !== "falling") continue;

        const v = Number.isFinite(w.fallSpeedOverride)
          ? w.fallSpeedOverride
          : (fallSpeed * (w.fallMult || 1) * (w.ex2FallMult || 1));
        w.y += v * dt;

        const baseCount = Number.isFinite(w.spawnBaseCount) ? w.spawnBaseCount : landedCount;
        const gIdx = (w.groupIndex || 0);
        const ignoreCollide = !!w.ex3Ghost || !!w.ignoreCollision;
        const targetY = ignoreCollide ? (h - 30) : (h - 30 * (baseCount + gIdx + 1));

        if(w.y >= targetY){
          w.y = targetY;

          w.state = "landed";
          w.el.classList.add("landed");
          if(isNormalStage5() && w.s5Highlighted && !w.s5Permafrost){
            stage5ArmFrost(w, elapsed);
          }
          if(isExtraStage1() && w.ex1Highlighted && !w.s5Permafrost){
            ex1ArmPermafrost(w);
          }
          if(isExtraStage2() && ex2Phase >= 3 && ex2Phase < 6){
            ex2ToggleObscureOnLand(w);
          }

          landedCount++;
          needsRestack = true;
        }

        setWordY(w.el, w.y);
      }

      stage5UpdateFrost();
      ex1UpdatePermafrost();

      // Normal Stage 2: highlighted words start flashing after halfway.
      // If not cleared within 3 seconds, the word disappears and the player takes 2 damage per word.
      if(isNormalStage2()){
        const halfY = h * 0.5;

        // Start flashing once past halfway
        for(let i=0;i<words.length;i++){
          const w = words[i];
          if(!w || !w.s2Highlighted) continue;
          if(!w.s2Flashing && w.y >= halfY){
            w.s2Flashing = true;
            w.s2FlashStartSec = elapsed;
            try{ w.el && w.el.classList.add("flash"); }catch(_){}
            startStage2FlashSfx(w);
          }
        }

        // Expire words that have been flashing for 3 seconds
        const expiredIds = [];
        for(let i=0;i<words.length;i++){
          const w = words[i];
          if(!w || !w.s2Flashing) continue;
          if((elapsed - (w.s2FlashStartSec || 0)) >= STAGE2_FLASH_WINDOW_SEC){
            expiredIds.push(w.id);
            if(w.state === "landed") landedCount = Math.max(0, landedCount - 1);
          }
        }
        if(expiredIds.length){
          for(const id of expiredIds) removeWord(id);
          damagePlayer(expiredIds.length * 2, "stage2 flash timeout");
          needsRestack = true;
        }
      }

      stage4UpdateCycle(dt);

      updateStage3Timer();
      updateStage4Timer();

      if(needsRestack) restackLanded();

      overflow = landedCount >= laneCapacity();
      if(overflow){
        overflowAcc += dt;
        if(overflowAcc >= 1){
          const ticks = Math.floor(overflowAcc);
          overflowAcc -= ticks;
          damagePlayer(ticks, "overflow");
        }
      }else{
        overflowAcc = 0;
      }

      handleStage5PhaseTriggers();
      updateStage5Timer();
      updateEx2Mechanic();
      updateEx4Mechanic();
      updateUIThrottled();
    } else {
      updateStage5Timer();
      updateStage3Timer();
      updateStage4Timer();
      updateEx2Mechanic();
      updateUIThrottled();
    }

    requestAnimationFrame(tick);
  }

  startCmd && startCmd.addEventListener("click", () => {
    if(["playing","countdown","dialogue","stageclear","continuePrompt","modeselect"].includes(gameState)) return;
    try{ tryPlayBgmFromGesture(); }catch(_){/* ignore */}
    showModeSelectScreen();

  });

profileCmd && profileCmd.addEventListener("click", () => {
  // Allow profile viewing/editing from safe states only
  if(["playing","paused","countdown","dialogue","stageclear","continuePrompt"].includes(gameState)) return;
  try{ tryPlayBgmFromGesture(); }catch(_){/* ignore */}
  openProfileModal(false);
});
achievementsCmd && achievementsCmd.addEventListener("click", () => {
  if(["playing","paused","countdown","dialogue","stageclear","continuePrompt"].includes(gameState)) return;
  try{ tryPlayBgmFromGesture(); }catch(_){/* ignore */}
  openAchievementsModal();
});

pauseCmd && pauseCmd.addEventListener("click", (e) => {
  if(gameState === "playing" && isExtraStage2()){
    pushMsg("⛔ Pause disabled in EX Stage 2", true);
    return;
  }
  // A click is a real user gesture: make resuming audio reliable on Safari/iPad.
  try{ tryPlayBgmFromGesture(); }catch(_){/* ignore */}
  togglePause(true);
});

// Global Pause hotkey (ESC): pause/resume.
window.addEventListener("keydown", (e) => {
  if(e.key !== "Escape") return;
  if(gameState === "playing"){
    if(isExtraStage2()){
      pushMsg("⛔ Pause disabled in EX Stage 2", true);
      return;
    }
    e.preventDefault();
    pauseGame();
  }else if(gameState === "paused"){
    e.preventDefault();
    resumeGame(true);
  }
});

  resetCmd && resetCmd.addEventListener("click", () => {
    if(gameState === "playing" && isExtraStage4() && ex4Phase === 4){
      // Block reset during the fake death phase
      ex4ShowFakeDeath(true);
      overlayDesc.textContent = "HAHAHAHAHAHA";
      ex4PlayResetScare();
      return;
    }
    resetGame();
  });
runCmd.addEventListener("click", () => {
    if(gameState === "playing" && isExtraStage4() && ex4Phase === 4){
      ex4ShowFakeDeath(true);
      overlayDesc.textContent = "HAHAHAHAHAHA";
      ex4PlayResetScare();
      return;
    }
    resetGame();
  });

  answerForm.addEventListener("submit", (e) => {
    e.preventDefault();
    submitAnswer();
  });

  bgmVol.addEventListener("input", () => {
    const v = Number(bgmVol.value) / 100;
    isMuted = false;
    try{ bgm.muted = false; }catch(_){/* ignore */}
    bgmMuteBtn.textContent = "MUTE";
    setBgmVolume(v);
    // Slider movement is a user gesture on most browsers: retry play.
    tryPlayBgm();
  });
  bgmMuteBtn.addEventListener("click", toggleMute);

  document.documentElement.style.setProperty("--wordH", String(30));
  initSfxPool();
  setBgmVolume(0.35);
  function bootGame(){
    // If the EX2 trap flag exists, force the player into the trap state on load.
    const p = loadEx2TrapPhase();
    if(p === "6"){
      // Stale flag from older builds: Phase 6 is not a trap state anymore.
      ex2TrapPhase = "";
      saveEx2TrapPhase("");
      try{ saveEx2ResumeSnapshot(null); }catch(_){/* ignore */}
    }
    if(p === "5"){
      ex2TrapPhase = "5";
      // Restore resume snapshot so Phase 6 can continue the EX2 song/timers even after a reload.
      ex2ResumeSnapshot = ex2ResumeSnapshot || loadEx2ResumeSnapshot();
      ex2EnterFakeStage1({fromBoot:true});
      return;
    }

    try{ renderProfileHeader(); }catch(_){/* ignore */}
    resetGame();
    showIntroStartScreen();
  }

  bootGame();

  requestAnimationFrame(tick);
})();</script>
</body>
</html>
